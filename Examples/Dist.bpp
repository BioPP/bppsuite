# Global variables:
DATA   = LSU
METHOD = bionj

# Sequences:

# The alphabet to use:
# DNA, RNA or Protein
alphabet=DNA

# The sequence file to use (sequences must be aligned!)
sequence.file=$(DATA).phy

# The alignment format:
# Must be one of Mase, Fasta, Phylip, Clustal, DCSE 
sequence.format=Phylip

# Mase format option:
sequence.format_mase.site_selection =

# Phylip format options:
# interleaved or sequential:
sequence.format_phylip.order = sequential

# classic or extended (PAML):
sequence.format_phylip.ext = extended

#Sites to use:
# all, nogap or complete (=only resolved chars)
sequence.sites_to_use = complete
# Specify a maximum amount of gaps: may be an absolute number or a percentage.
sequence.max_gap_allowed=100%

# Output the distance matrix if any.
output.matrix.file = $(DATA).mat

# ----------------------------------------------------------------------------------------
#                                     Model specification
# ----------------------------------------------------------------------------------------

# Available models.
# For proteins, the DCmutt method is used for JTT92 and DSO78.
# You can use the 'empirical' option to specify another model.
# JCnuc, K80, T92, HKY85, F84, TN93, JCprot, DSO78, JTT92 or empirical
# Append +G2001 or +TS98 to the model name to add a covarion model.
model.name = HKY85

# Initial values for parameters:
# kappa (K80, T92, HKY85, F84)
# kappa1, kappa2 (TN93)
# theta (T92)
# pi1, piT, piC and piG (HKY85, F84 and TN93)
model.kappa = 2.843
model.piA = 0.13
model.piT = 0.16
model.piC = 0.31
model.piG = 0.40

#Tell if we have to use observed frequencies as parameter values (for piA, piT, piG, piC and theta).
#For proteins, this is equivalent to the -F model family.
model.use_observed_freq = yes

#If empirical is set, specify the path where to find model (in PAML format).
model_empirical.file = 

# Rate Across Sites variation:
# gamma or constant [+invariant]
rate_distribution = gamma

# The gamma distribution's shape parameter
rate_distribution.alpha = 0.358

# Number of classes for discretization:
rate_distribution.classes_number = 4

# The proportion of invariants
rate_distribution.p = 0.2

#Covarions:
#G2001:
model.nu=1.
model.rate_distribution=gamma //only choice for now
model.rate_distribution.classes_number = 4
model.alpha = 0.358
#TS98:
model.s1=1.
model.s2=1.

# Tree reconstruction method [wpgma|upgma|nj|bionj]
method = $(METHOD)
// Parameter estimation:
// - init = keep as initial values,
// - pairwise = estimate separately for each pair of sequences,
// - iterations = use iterations and ML to estimate these parameters globally.
optimization.method = init
optimization.verbose = 1
optimization.ignore_parameter =
optimization.max_number_f_eval = 10000
optimization.tolerance = 0.000001
optimization.message_handler = $(DATA).messages
optimization.profiler = $(DATA).profile

# Should we write the resulting tree? none or file name.
output.tree.file = $(DATA).$(METHOD).dnd

# Bootstrap:
bootstrap.number = 10
bootstrap.approximate = no
# Set this to yes for detailed output when bootstrapping. 
bootstrap.verbose = no
bootstrap.output.file = $(DATA).$(METHOD)_bstrees.dnd

