# Global variables:
DATA = LSU

# Sequences:

# The alphabet to use:
# DNA, RNA or Protein
alphabet=DNA

# The sequence file to use (sequences must be aligned!)
sequence.file=$(DATA)small.paml

# The alignment format:
# Must be one of Mase, Fasta, Phylip, Clustal, DCSE 
sequence.format=Phylip

# Mase format option:
sequence.format_mase.site_selection =

# Phylip format options:
# interleaved or sequential:
sequence.format_phylip.order = sequential

# classic or extended (PAML):
sequence.format_phylip.ext = extended

#Sites to use:
# all, nogap or complete (=only resolved chars)
sequence.sites_to_use = complete
# Specify a maximum amount of gaps: may be an absolute number or a percentage.
sequence.max_gap_allowed = 100%

tree.file = LSU.dnd

# Print a tree with ids as bootstrap values.
# This is helpful when setting up complexe non-homogeneous models.
# Setting this option will cause the program to exit after printing the tree.
//output.tree.path = LSUrooted_wid.dnd

# ----------------------------------------------------------------------------------------
#                                     Model specification
# ----------------------------------------------------------------------------------------

# Homogeneous model?
# no => Homogeneous case
# one_per_branch => Galtier & Gouy 97 series of NH models
# general => Specify the model by hand.
nonhomogeneous = one_per_branch

# Options for non-homogeneous one-per_branch models:

# Available models.
# For proteins, the DCmutt method is used for JTT92 and DSO78.
# You can use the 'empirical' option to specify another model.
# JCnuc, K80, T92, HKY85, F84, TN93, JCprot, DSO78, JTT92 or empirical
# Append +G2001 or +TS98 to the model name to add a covarion model.
model.name = T92

# Initial values for parameters:
# kappa (K80, T92, HKY85, F84)
# kappa1, kappa2 (TN93)
# theta (T92)
# pi1, piT, piC and piG (HKY85, F84 and TN93)
model.kappa = 2.843
model.theta = 0.5

#If empirical is set, specify the path where to find the model description (in PAML format).
model_empirical.file = 

#Covarions:
#G2001:
model.nu=1.
model.rate_distribution=gamma //only choice for now
model.rate_distribution.classes_number = 4
model.alpha = 0.358
#TS98:
model.s1=1.
model.s2=1.

# For one_per_branch heterogeneous models.
# Tell which parameters are common to all branches.
# Other parameters will be considered branch specific.
nonhomogeneous_one_per_branch.shared_parameters = kappa

# How to deal with root frequencies:
# balanced  : all frequencies are set to 1/size of the alphabet
# observed  : use observed counts in the data set
# init      : manually set the frequencies (they have to sum to one)
# For nucleotides, one can use the GC rate (theta) parametrization, like in the T92 model:
# balancedGC: ancestral GC set to 0.5
# observedGC: use observed GC content
# initGC    : manually set the ancestral GC content.
nonhomogeneous.root_freq=balancedGC

# If the init option is selcted, ignored otherwise:
model.ancA=
model.ancC=
model.ancG=
model.ancT=
# or:
model.ancA=
model.ancR=
model.ancN=
#etc

# If the initGC option is used, ignored otherwise:
model.ancTheta=0.5

# Rate Across Sites variation:
# gamma or constant
rate_distribution = gamma

# The gamma distribution's shape parameter
rate_distribution.alpha = 0.358

# Number of classes for discretization:
rate_distribution.classes_number = 4

# Likelihood recursion option:
# - simple: derivatives takes more time to compute, but likelihooh computation is faster.
#   For big data sets, it can save a lot of memory usage too, particularly when the data are compressed.
# - double: Uses more memory and need more time to compute likelihood, due to the double recursion.
#   Analytical derivatives are however faster to compute.
likelihood.recursion = simple

# Site compression for the simple recursion:
# - simple: identical sites are not computed twice
# - recursive: look for site patterns to save computation time during optimization, but
#   requires extra time for building the patterns.
#   This is usually the best option, particularly for nucleotides data sets.
likelihood.recursion_simple.compression = recursive

# ----------------------------------------------------------------------------------------
#                                     Optimization
# ----------------------------------------------------------------------------------------

optimization=yes
optimization.verbose = 1
optimization.ignore_parameter =
optimization.max_number_f_eval = 10000
optimization.tolerance = 0.000001
optimization.message_handler = $(DATA).messages
optimization.profiler = $(DATA).profile

optimization.topology = no
optimization.topology.nstep=4
optimization.topology.numfirst=no
optimization.topology.tolerance.before=100
optimization.topology.tolerance.during=100
optimization.method=fullD //[DB|fullD]
optimization.method_DB.nstep=15
optimization.scale_first=no
optimization.verbose=3
#optimization.ignore_parameter=piA,piC,piT,piG

# Should we write the resulting tree? none or file name.
output.tree.file = $(DATA)ML.dnd

# Alignment information log file (site specific rates, etc):
output.infos = $(DATA).infos

# Write numerical parameter estimated values:
output.estimates = $(DATA).params.txt

# ----------------------------------------------------------------------------------------
#                                     Bootstrap
# ----------------------------------------------------------------------------------------

bootstrap.number = 0
# Tell if numerical parameters should be kept to their initial value when bootstrapping: 
bootstrap.approximate = no
# Set this to yes for detailed output when bootstrapping. 
bootstrap.verbose = no
bootstrap.output.file = $(DATA)ML_bstrees.dnd

