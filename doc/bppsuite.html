<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the manual of the Bio++ Program Suite, version 2.4.0.

Copyright (C) 2007-2018 Bio++ development team -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>BppSuite Manual 3.0.0</title>

<meta name="description" content="BppSuite Manual 3.0.0">
<meta name="keywords" content="BppSuite Manual 3.0.0">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/Core/Steely">


</head>

<body lang="en">
<h1 class="settitle" align="center">BppSuite Manual 3.0.0</h1>



<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a id="toc-Syntax-description" href="#Syntax">2 Syntax description</a>
  <ul class="no-bullet">
    <li><a id="toc-Calling-the-programs-and-writing-the-option-files_002e" href="#Calling-the-programs-and-writing-the-option-files_002e">2.1 Calling the programs and writing the option files.</a></li>
    <li><a id="toc-Different-types-of-options" href="#Different-types-of-options">2.2 Different types of options</a></li>
    <li><a id="toc-Variables" href="#Variables">2.3 Variables</a></li>
  </ul></li>
  <li><a id="toc-Common-options-encountered-in-several-programs_002e" href="#Common">3 Common options encountered in several programs.</a>
  <ul class="no-bullet">
    <li><a id="toc-Setting-alphabet-and-genetic-code" href="#Alphabet">3.1 Setting alphabet and genetic code</a></li>
    <li><a id="toc-Reading-sequences" href="#Sequences">3.2 Reading sequences</a></li>
    <li><a id="toc-Reading-trees" href="#Tree">3.3 Reading trees</a></li>
    <li><a id="toc-Specifying-biochemical-properties-and-distances" href="#AlphabetIndex">3.4 Specifying biochemical properties and distances</a>
    <ul class="no-bullet">
      <li><a id="toc-Index1" href="#Index1">3.4.1 Index1</a></li>
      <li><a id="toc-Index2" href="#Index2">3.4.2 Index2</a></li>
    </ul></li>
    <li><a id="toc-Declaring-Phylo_002dlikelihoods" href="#Likelihoods">3.5 Declaring Phylo-likelihoods</a>
    <ul class="no-bullet">
      <li><a id="toc-Setting-up-the-substitution-models" href="#Model">3.5.1 Setting up the substitution models</a>
      <ul class="no-bullet">
        <li><a id="toc-Nucleotide-models" href="#Nucleotide">3.5.1.1 Nucleotide models</a></li>
        <li><a id="toc-Protein-models" href="#Protein">3.5.1.2 Protein models</a></li>
        <li><a id="toc-Miscellaneous-models" href="#Miscellaneous">3.5.1.3 Miscellaneous models</a></li>
        <li><a id="toc-Codon-models" href="#Codon">3.5.1.4 Codon models</a></li>
        <li><a id="toc-General-multiple-site-models" href="#Multiple">3.5.1.5 General multiple site models</a></li>
        <li><a id="toc-Meta-models" href="#Meta">3.5.1.6 Meta models</a></li>
        <li><a id="toc-Mixture-of-models" href="#Mixture">3.5.1.7 Mixture of models</a></li>
        <li><a id="toc-Paths-among-non_002dhomogeneous-mixture-models" href="#Paths-among-non_002dhomogeneous-mixture-models">3.5.1.8 Paths among non-homogeneous mixture models</a></li>
        <li><a id="toc-Conditioned-models" href="#Conditioned">3.5.1.9 Conditioned models</a></li>
      </ul></li>
      <li><a id="toc-Setting-up-the-root-frequencies" href="#Root">3.5.2 Setting up the root frequencies</a></li>
      <li><a id="toc-Declaring-frequencies-sets" href="#FrequenciesSet">3.5.3 Declaring frequencies sets</a></li>
      <li><a id="toc-Setting-up-substitution-rates" href="#Rates">3.5.4 Setting up substitution rates</a></li>
      <li><a id="toc-Setting-up-the-process" href="#Process">3.5.5 Setting up the process</a></li>
      <li><a id="toc-Setting-up-phylo_002dlikelihoods" href="#Phylo_002dlikelihoods">3.5.6 Setting up phylo-likelihoods</a></li>
      <li><a id="toc-Linking-parameters" href="#Linking">3.5.7 Linking parameters</a></li>
    </ul></li>
    <li><a id="toc-Discrete-distributions-1" href="#Distribution">3.6 Discrete distributions</a>
    <ul class="no-bullet">
      <li><a id="toc-Standard-Distributions" href="#Standard-Distributions">3.6.1 Standard Distributions</a></li>
      <li><a id="toc-Mixture-Distributions" href="#Mixture-Distributions">3.6.2 Mixture Distributions</a></li>
    </ul></li>
    <li><a id="toc-Numerical-parameters-estimation" href="#Estimation">3.7 Numerical parameters estimation</a></li>
    <li><a id="toc-Writing-sequences_002falignments-to-files" href="#WritingSequences">3.8 Writing sequences/alignments to files</a></li>
    <li><a id="toc-Writing-trees-to-files" href="#WritingTrees">3.9 Writing trees to files</a></li>
  </ul></li>
  <li><a id="toc-Bio_002b_002b-Program-Suite-Reference" href="#Reference">4 Bio++ Program Suite Reference</a>
  <ul class="no-bullet">
    <li><a id="toc-BppML_003a-Bio_002b_002b-Maximum-Likelihood" href="#bppml">4.1 BppML: Bio++ Maximum Likelihood</a>
    <ul class="no-bullet">
      <li><a id="toc-Branch-lengths-initial-values" href="#Branch-lengths-initial-values">4.1.1 Branch lengths initial values</a></li>
      <li><a id="toc-Topology-optimization" href="#Topology-optimization">4.1.2 Topology optimization</a></li>
      <li><a id="toc-Molecular-clock" href="#Molecular-clock">4.1.3 Molecular clock</a></li>
      <li><a id="toc-Output-results" href="#Output-results">4.1.4 Output results</a></li>
      <li><a id="toc-Bootstrap-analysis" href="#Bootstrap-analysis">4.1.5 Bootstrap analysis</a></li>
      <li><a id="toc-Rather-technical-options" href="#Rather-technical-options">4.1.6 Rather technical options</a></li>
    </ul></li>
    <li><a id="toc-BppSeqGen_003a-Bio_002b_002b-Sequence-Simulator" href="#bppseqgen">4.2 BppSeqGen: Bio++ Sequence Simulator</a></li>
    <li><a id="toc-BppAncestor_003a-Bio_002b_002b-Ancestral-Sequence-and-Rate-Reconstruction" href="#bppancestor">4.3 BppAncestor: Bio++ Ancestral Sequence and Rate Reconstruction</a></li>
    <li><a id="toc-BppMixedLikelihoods_003a-Bio_002b_002b-Site_002dLikelihoods-Inside-Mixed-Models_002e" href="#bppmixedlikelihoods">4.4 BppMixedLikelihoods: Bio++ Site-Likelihoods Inside Mixed Models.</a></li>
    <li><a id="toc-BppDist_003a-Bio_002b_002b-Distance-Methods" href="#bppdist">4.5 BppDist: Bio++ Distance Methods</a></li>
    <li><a id="toc-BppPars_003a-Bio_002b_002b-Maximum-Parsimony" href="#bpppars">4.6 BppPars: Bio++ Maximum Parsimony</a></li>
    <li><a id="toc-BppConsense_003a-Bio_002b_002b-Consensus-Trees" href="#bppconsense">4.7 BppConsense: Bio++ Consensus Trees</a></li>
    <li><a id="toc-BppReroot_003a-Bio_002b_002b-Serial-Tree-Re_002drooting" href="#bppreroot">4.8 BppReroot: Bio++ Serial Tree Re-rooting</a></li>
    <li><a id="toc-BppSeqMan_003a-Bio_002b_002b-Sequence-Manipulation" href="#bppseqman">4.9 BppSeqMan: Bio++ Sequence Manipulation</a></li>
    <li><a id="toc-BppAlnScore_003a-Bio_002b_002b-Alignment-Scoring" href="#bppalnscore">4.10 BppAlnScore: Bio++ Alignment Scoring</a></li>
    <li><a id="toc-BppPopStats_003a-Bio_002b_002b-Population-Genetics-Statistics" href="#bpppopstats">4.11 BppPopStats: Bio++ Population Genetics Statistics</a>
    <ul class="no-bullet">
      <li><a id="toc-Specific-options" href="#Specific-options">4.11.1 Specific options</a></li>
      <li><a id="toc-Available-statistics" href="#Available-statistics">4.11.2 Available statistics</a></li>
    </ul></li>
    <li><a id="toc-BppTreeDraw_003a-Bio_002b_002b-Tree-Drawing" href="#bpptreedraw">4.12 BppTreeDraw: Bio++ Tree Drawing</a></li>
  </ul></li>
</ul>
</div>


<span id="Top"></span><div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="The-Bio_002b_002b-Program-Suite-Manual"></span><h1 class="top">The Bio++ Program Suite Manual</h1>

<p>This is the manual of the Bio++ Program Suite, version 2.4.0.
</p>
<p>Copyright &copy; 2007-2018 Bio++ development team
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Introducing the Bio++ Program Suite and this manual.                
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Syntax" accesskey="2">Syntax</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">A general description of the syntax used to communicate with the programs.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Common" accesskey="3">Common</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Common options shared by several programs.                      
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference" accesskey="4">Reference</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The exhaustive list of options available for all programs in the Bio++ Program Suite.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment"> &mdash; The Detailed Node Listing &mdash;

Common options encountered in several programs.

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Alphabet" accesskey="5">Alphabet</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Alphabets and genetic codes.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequences" accesskey="6">Sequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Loading sequences/alignments.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree" accesskey="7">Tree</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Loading trees.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#AlphabetIndex" accesskey="8">AlphabetIndex</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Setting biochemical properties and distances. 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Likelihoods" accesskey="9">Likelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Distribution">Distribution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Setting of the discrete distributions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Estimation">Estimation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Estimating parameters by maximizing a likelihood function.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#WritingSequences">WritingSequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Writing sequences/alignments to files. 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#WritingTrees">WritingTrees</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Writing trees to files. 
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Declaring Phylo-likelihoods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Model">Model</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Markov model specification
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Root">Root</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Root frequencies
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FrequenciesSet">FrequenciesSet</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Frequencies 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rates">Rates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Rates across sites
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Process">Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Process along trees
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Phylo_002dlikelihoods">Phylo-likelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linking">Linking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Setting up the substitution models

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Nucleotide">Nucleotide</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Nucleotide models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Protein">Protein</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Protein models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous">Miscellaneous</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Miscellaneous models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Codon">Codon</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Codon models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Multiple">Multiple</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">General multiple site models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Meta">Meta</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Meta models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mixture">Mixture</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Mixture of models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conditioned">Conditioned</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Models conditioned by events
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Bio++ Program Suite Reference

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#bppml">bppml</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Maximum Likelihood.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppseqgen">bppseqgen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Sequence Generator.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppancestor">bppancestor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Ancestral Sequences and Rates reconstruction.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppmixedlikelihoods">bppmixedlikelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Site-Likelihoods Inside Mixed Models.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppdist">bppdist</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Distance Methods.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpppars">bpppars</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Maximum Parsimony.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppconsense">bppconsense</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Consensus Trees.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppreroot">bppreroot</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Serial Tree Re-rooting.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppseqman">bppseqman</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Sequences Manipulation.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppalnscore">bppalnscore</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Alignment Scoring.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpppopstats">bpppopstats</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Population Genetics Statistics.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpptreedraw">bpptreedraw</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Tree Drawing.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></table>


<hr>
<span id="Introduction"></span><div class="header">
<p>
Next: <a href="#Syntax" accesskey="n" rel="next">Syntax</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Introduction-1"></span><h2 class="chapter">1 Introduction</h2>

<p>The Bio++ Program Suite is a package of programs using the Bio++ libraries and dedicated to Phylogenetics and Molecular Evolution.
All programs are independent, but can be combined to perform rather complex analyses.
These programs use the interface helper tools of the libraries, and hence share the same syntax.
They also have several options in common, which may also be shared by third-party software.
This manual was hence split into three parts: 
</p><dl compact="compact">
<dt><em>Bio++ option file syntax</em></dt>
<dd><p>A general description of the language used to interact with the programs.
</p>
</dd>
<dt><em>Shared options</em></dt>
<dd><p>A more detailed description about several options that are encountered in several programs.
This includes input/output of data and model specifications.
</p>
</dd>
<dt><em>The Bio++ Program Suite reference</em></dt>
<dd><p>Include a reference of all available options for each program in the package.
</p>
</dd>
</dl>


<hr>
<span id="Syntax"></span><div class="header">
<p>
Next: <a href="#Common" accesskey="n" rel="next">Common</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Syntax-description"></span><h2 class="chapter">2 Syntax description</h2>

<span id="Calling-the-programs-and-writing-the-option-files_002e"></span><h3 class="section">2.1 Calling the programs and writing the option files.</h3>

<p>The programs in the Bio++ Program Suite are command line-driven.
Arguments may be passed as <code>parameter=value</code> options, either directly to the command line or
using an option file:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">{program} parameter1=value1 parameter2=value2 ... parameterN=valueN
</pre></div>
</td></tr></table>
<p>or
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">{program} param=option_file
</pre></div>
</td></tr></table>
<p>where {program} is the name of the program to use (bppml, bppseqgen,
etc.). Option files contain <code>parameter=value</code> lines, with only
one parameter per line. They can be written from scratch using a
regular text editor, but since these files can potentially turn to be
quite complex, it is probably wiser to start with a sample provided
along with the program (if any!).
</p>
<p>Extra-space may be included between parameter names, equal sign and value:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">first_parameter   = value1
second_parameter  = value2
</pre></div>
</td></tr></table>
<p>and lines can be broken using the backslash character:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">parameter = value1,\
            value2,\
            value3
</pre></div>
</td></tr></table>

<p>Comment may be included, in either scripting format:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example"># This is a comment
</pre></div>
</td></tr></table>
<p>C format:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">/* This is a comment
*/
</pre></div>
</td></tr></table>
<p>or C++ format:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">// This is a comment
</pre></div>
</td></tr></table>
<p>Command line and file options may be combined:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">{program} param=option_file parameterX=valueX
</pre></div>
</td></tr></table>
<p>In case <code>parameterX</code> is specified in both option file and
command line, the command line value will be used. This allows to run
the programs several times by changing a single option, like the name
of the data set for instance.
</p>
<p>Option files can be nested, by using <code>param=nestedoptionfile</code>
within an option file, as with the command line. It is possible to use
this option as often as needed, this will load all the required option
files.
</p>
<span id="Different-types-of-options"></span><h3 class="section">2.2 Different types of options</h3>

<p>The next chapters describe the whole set of options available in BppSuite.
For each parameter, the type of parameter value expected is defined as:
</p><dl compact="compact">
<dt><code>{chars}</code></dt>
<dd><p>A character chain
</p>
</dd>
<dt><code>{path}</code></dt>
<dd><p>A file path, which may be absolute or related to the current directory
</p>
</dd>
<dt><code>{int}</code></dt>
<dd><p>An integer
</p>
</dd>
<dt><code>{int}, {int&gt;0}, {int&gt;=0}, {int[2,10]}</code></dt>
<dd><p>An integer, a positive integer, a positive non-null integer, an
integer falling between 2 and 10
</p>
</dd>
<dt><code>{real}, {real&gt;0}, etc</code></dt>
<dd><p>A real number, a positive real number, etc.
</p>
</dd>
<dt><code>{boolean}</code></dt>
<dd><p>A Boolean value, which may be one of &rsquo;yes&rsquo;, &rsquo;no&rsquo;, &rsquo;true&rsquo; or &rsquo;false&rsquo;
</p>
</dd>
<dt><code>{xxx|yyy|zzz}</code></dt>
<dd><p>A set of allowed values
</p>
</dd>
<dt><code>{list&lt;type&gt;}</code></dt>
<dd><p>A list of values of specified type, separated by comas.
</p>
</dd>
</dl>

<p>If an option availability or choice depends on another parameters, it will be noted as
</p>
<div class="example">
<pre class="example">parameter1={xxx|yyy|zzz}

parameter2={chars} [[parameter1=zzz]]
</pre></div>
<p>meaning that parameter2 is available only if parameter1 is set to &rsquo;zzz&rsquo;.
</p>
<p>Any optional argument will be noted within hooks [].
</p>
<p>In some cases, the argument value is more complexe and follows the &rsquo;keyval&rsquo;
syntax.
This syntax will be quite familiar for users using languages like R, Python, or
certain LaTeX packages.
A keyval procedure is a name that does no contain any space, together with some
arguments within parentheses.
The arguments take the form <code>key=value</code>, separated by comas:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">parameter=Function(name1=value1, name2=value2)
</pre></div>
</td></tr></table>
<p>Space characters are allowed around the &rsquo;=&rsquo; and &rsquo;,&rsquo; ponctuations.
</p>
<span id="Variables"></span><h3 class="section">2.3 Variables</h3>

<p>It is possible to recall anywhere the value of an option by using $(parameter).
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">topo.algo = NNI
topo.algo_nni.method = phyml
output.tree.file = MyData_$(topo.algo)_$(topo.algo_nni.method).dnd
</pre></div>
</td></tr></table>
<p>You can use this syntax to define global variables:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">data=MyData
input.data1 = alignment(file=$(data).fasta)
input.tree1 = user(file=$(data).dnd)
output.infos=$(data).infos
</pre></div>
</td></tr></table>

<p>Important note: it is not possible to use a macro with the &rsquo;param&rsquo; option.
This is because all nested option files are parsed before the variable resolution.
Writing <code>param=$(model1).bpp</code> will not work, but this allows the user to override variables in nested files, as with the command line.
For instance:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">#Option file 1:
param=options2.bpp
input.data1=alignment(file=$(data).fasta, format=Fasta)
</pre></div>
</td></tr></table>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">#Option file 2:
data=LSU
#etc
</pre></div>
</td></tr></table>
 

<hr>
<span id="Common"></span><div class="header">
<p>
Next: <a href="#Reference" accesskey="n" rel="next">Reference</a>, Previous: <a href="#Syntax" accesskey="p" rel="prev">Syntax</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Common-options-encountered-in-several-programs_002e"></span><h2 class="chapter">3 Common options encountered in several programs.</h2>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Alphabet" accesskey="1">Alphabet</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Alphabets and genetic codes.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequences" accesskey="2">Sequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Loading sequences/alignments.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree" accesskey="3">Tree</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Loading trees.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#AlphabetIndex" accesskey="4">AlphabetIndex</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Setting biochemical properties and distances. 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Likelihoods" accesskey="5">Likelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Distribution" accesskey="6">Distribution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Setting of the discrete distributions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Estimation" accesskey="7">Estimation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Estimating parameters by maximizing a likelihood function.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#WritingSequences" accesskey="8">WritingSequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Writing sequences/alignments to files. 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#WritingTrees" accesskey="9">WritingTrees</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Writing trees to files. 
</td></tr>
</table>

<hr>
<span id="Alphabet"></span><div class="header">
<p>
Next: <a href="#Sequences" accesskey="n" rel="next">Sequences</a>, Previous: <a href="#Common" accesskey="p" rel="prev">Common</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-alphabet-and-genetic-code"></span><h3 class="section">3.1 Setting alphabet and genetic code</h3>

<dl compact="compact">
<dt><code>alphabet =</code></dt>
<dd><p>{DNA|RNA|Protein|Binary|Lexicon(words=(list of words))|Word(letter={DNA|RNA|Protein},length={int})|\
Codon(letter={DNA|RNA}, type={Standard|EchinodermMitochondrial|InvertebrateMitochondrial|\
VertebrateMitochondrial})}
The alphabet to use when reading sequences. DNA and RNA alphabet can in addition take an argument:
</p>
<dl compact="compact">
<dt><code>bangAsgap={bool}</code></dt>
<dd><p>Tell is exclamation mark should be considered as a gap character. The default is to consider it as an unknown character such as &rsquo;N&rsquo; or &rsquo;?&rsquo;.
</p></dd>
</dl>

</dd>
<dt><code>genetic_code = {translation table}</code></dt>
<dd><p>The genetic code used for codon alphabet, where &rsquo;translation table&rsquo;
specifies the code to use, either as a text description, or as the
NCBI number. The following table give the currently implemented codes
with their corresponding names:
</p>
<table>
<tr><td width="50%">Standard</td><td width="50%">1</td></tr>
<tr><td width="50%">VertebrateMitochondrial</td><td width="50%">2</td></tr>
<tr><td width="50%">YeastMitochondrial</td><td width="50%">3</td></tr>
<tr><td width="50%">MoldMitochondrial</td><td width="50%">4</td></tr>
<tr><td width="50%">InvertebrateMitochondrial</td><td width="50%">5</td></tr>
<tr><td width="50%">CiliateNuclear</td><td width="50%">6</td></tr>
<tr><td width="50%">EchinodermMitochondrial</td><td width="50%">9</td></tr>
<tr><td width="50%">AscidianMitochondrial</td><td width="50%">13</td></tr>
</table>

</dd>
</dl>

<p>The states of the alphabets are in alphabetical order. For the proteic
alphabet, the amino-acid are in the order of their 3-letters code
(ALA, ARG, ASN, ...).
</p>
<dl compact="compact">
<dt><code>Lexicon(words=(list of words))</code></dt>
<dd><p>builds an alphabet of any set of words, as long as they have the same
length. Gap (resp. unknown) word is then a word of &quot;-&quot; (resp. &quot;?&quot;) of
the same length.
</p></dd>
</dl>


<hr>
<span id="Sequences"></span><div class="header">
<p>
Next: <a href="#Tree" accesskey="n" rel="next">Tree</a>, Previous: <a href="#Alphabet" accesskey="p" rel="prev">Alphabet</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Reading-sequences"></span><h3 class="section">3.2 Reading sequences</h3>

<p>Sequences are numbered as data like this:
</p>
<dl compact="compact">
<dt><code>input.data{number} = alignment({alignment arguments})</code></dt>
<dd><p>A description of the set of sequence analysed, using the keyval syntax.
</p>
</dd>
</dl>

<p>The available arguments are : 
</p><dl compact="compact">
<dt><code>file={path}</code></dt>
<dd><p>The sequence file to use. Depending on the program, these sequences
have or do not have to be aligned.
</p>
</dd>
<dt><code>format = {sequence format description}</code></dt>
<dd><p>The sequence file format.
</p>
</dd>
<dt><code>selection = {list of integers}</code></dt>
<dd><p>Will only consider sites in the given list of positions, in extended
format : positions separated with &quot;,&quot;, and &quot;i-j&quot; for all positions
between i and j, included.
</p>
</dd>
<dt><code>selection = {Sample(n={integer} [, replace={true}])}</code></dt>
<dd><p>Will consider {n} random sites, with optional replacement.
</p>
</dd>
</dl>
<p>Since Bio++ Program Suite version 0.4.0, the format description uses
the keyval syntax. The format is a function, with optional parameters:
</p>
<dl compact="compact">
<dt><code>Fasta(extended={bool}, strictNames={bool})</code></dt>
<dd><p>The fasta format.
The argument <code>extended</code>, default to &rsquo;no&rsquo;, allows to enable the
HUPO-PSI extension of the format.
The argument <code>strict_names</code>, default to &rsquo;no&rsquo;, specifies that
only the first word in the fasta header is used as a sequence names,
the rest of the header being considered as comments.
</p>
</dd>
<dt><code>Mase(siteSelection={chars})</code></dt>
<dd><p>The Mase format (as read by Seaview and Phylo_win for instance), with
an optional site selection name.
</p>
</dd>
<dt><code>Phylip(order={interleaved|sequential}, type={classic|extended}, split={spaces|tab})</code></dt>
<dd>
<p>The Phylip format, with several variations. The argument
<code>order</code> distinguishes between sequential and interleaved
format, while the option <code>type</code> distinguished between the
plain old Phylip format and the more recent extension allowing for
sequence names longer than 10 characters, as understood by PAML and
PhyML. Finally, the <code>split</code> argument specifies the type of
character that separates the sequence name from the sequence content.
The conventional option is to use one (classic) or more (extended)
spaces, but tabs can also be used instead.
</p>
</dd>
<dt><code>Clustal(extraSpaces={int})</code></dt>
<dd><p>The Clustal format. 
In its basic set up, sequence names do not have space characters, and
one space splits the sequence content from its name. The parser can
however be configured to allow for spaces in the sequence names,
providing a minimum number of space characters is used to split the
content from the name. Setting <code>extraSpaces</code> to 5 for
instance, the sequences are expected to be at least 6 spaces away for
their names.
</p>
</dd>
<dt><code>Dcse()</code></dt>
<dd><p>The DCSE alignment format. The secondary structure annotation will be
ignored.
</p>
</dd>
<dt><code>Nexus()</code></dt>
<dd><p>The Nexus alignment format. Only very basic support is provided.
</p>
</dd>
</dl>

<p>For programs that do not require the sequences to be aligned, the
following formats are also available:
</p><dl compact="compact">
<dt><code>GenBank()</code></dt>
<dd><p>Very basic support: only retrieves the sequence content for now, all
features are ignored.
</p>
</dd>
</dl>

<p>Basic operations can be performed on the sequences:
</p>
<dl compact="compact">
<dt><code>sites_to_use = {all|nogap|complete}</code></dt>
<dd><p>This option only works if the program requires an alignment.
Tells which sites to use (default: &rsquo;complete&rsquo;).
The <samp>nogap</samp> option removes all sites containing at least one
gap, and the <samp>complete</samp> option removes all sites containing at
least one gap or one generic character, as &rsquo;X&rsquo; for instance.
</p>
</dd>
<dt><code>remove_stop_codons = {boolean}</code></dt>
<dd><p>This option only works if the alphabet is a codon alphabet. Removes
the sites where there is a stop codon (default: &rsquo;yes&rsquo;).
</p>
</dd>
<dt><code>max_gap_allowed={percentage|number}</code></dt>
<dd><p>This option only works if the program requires an alignment. Only
works when the <samp>all</samp> option is selected. It specifies the
maximum amount of gap allowed per site, as a number of sequence or a
percentage (detected if symbol {\%} is used). Sites not matching the
criterion will not be included in the analysis, but the original site
numbering will be used in the output files (if relevant).
</p>
</dd>
<dt><code>max_unresolved_allowed={percentage|number}</code></dt>
<dd><p>This option only works if the program requires an alignment. Only
works when the <samp>all</samp> option is selected. It specifies the
maximum amount of unresolved states per site, as a number of sequence
or a percentage. Sites not matching the criterion will not be included
in the analysis, but the original site numbering will be used in the
output files (if relevant).
</p>
</dd>
</dl>
 

<hr>
<span id="Tree"></span><div class="header">
<p>
Next: <a href="#AlphabetIndex" accesskey="n" rel="next">AlphabetIndex</a>, Previous: <a href="#Sequences" accesskey="p" rel="prev">Sequences</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Reading-trees"></span><h3 class="section">3.3 Reading trees</h3>

<p>Trees are numbered like this:
</p>
<dl compact="compact">
<dt><code>input.tree{number} = {user|random}({tree arguments})</code></dt>
<dd><p>A description of the tree used, using the keyval syntax.
</p>
</dd>
</dl>

<p>A tree can be declared as given by the user from a file, or to be
random from an alignment number.
</p>
<p>If the tree is given by the user, the arguments are :
</p>
<dl compact="compact">
<dt><code>file = {path}</code></dt>
<dd><p>The phylogenetic tree file to use.
</p>
</dd>
<dt><code>format = {Newick|Nexus|NHX}</code></dt>
<dd><p>The format of the input tree file.
</p>
</dd>
</dl>

<p>If the tree is random, the arguments are :
</p>
<dl compact="compact">
<dt><code>data = {number}</code></dt>
<dd><p>The number of the data from which the leaf names will used.
</p>
</dd>
</dl>

<p>Some programs may require that your file contains several trees. In
this case the syntax is 
</p>
<dl compact="compact">
<dt><code>input.tree = user(file = {path}[,{other options}])</code></dt>
<dd><p>The file containing multiple trees.
</p></dd>
</dl>


<p>The branch lengths can be aliased to other parameters (such as other
branch lengths) as in the example:
</p>
<div class="example">
<pre class="example">input.tree1 = user(file = ftree1.dnd, BrLen0=BrLen1, BrLen2=BrLen3_2)
input.tree2 = user(file = ftree2.dnd)
</pre></div>

<p>which means that the branch 0 of tree 1 is aliased to the branch 1 of
tree 1, and branch 2 of tree 1 is aliased to branch 3 of tree 2.
</p>

<p>In case the input tree does not specify node identifiers, some will be
generated automatically. Nodes identifiers can be outputed using the
following option:
</p>
<dl compact="compact">
<dt><code>output.tree_ids.file = {{path}|none}</code></dt>
<dd><p>A tree file in newick format, with node ids instead of bootstrap
values, and leaf names with their id as suffix.
</p></dd>
</dl>

<p>In case it is supported by the program (only bppml), the use of that
option will cause the program to exit just after producing the tagged
tree.
</p>


<hr>
<span id="AlphabetIndex"></span><div class="header">
<p>
Next: <a href="#Likelihoods" accesskey="n" rel="next">Likelihoods</a>, Previous: <a href="#Tree" accesskey="p" rel="prev">Tree</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Specifying-biochemical-properties-and-distances"></span><h3 class="section">3.4 Specifying biochemical properties and distances</h3>

<p>Some methods require an &quot;alphabet index&quot; to be specified. Alphabet
indexes associate a value with each alphabet state (Index1, e.g. a
biochemical property) or for a pair of states (Index2, e.g. a
biochemical distance). This section describes the supported indexes:
</p>
<span id="Index1"></span><h4 class="subsection">3.4.1 Index1</h4>

<dl compact="compact">
<dt><code>None</code></dt>
<dd><p>If no index should be used.
</p></dd>
<dt><code>Surface, Mass, Volume, Charge {AA}</code></dt>
<dd><p>Basic amino acids properties.
</p></dd>
<dt><code>GranthamPolarity, GranthamVolume {AA}</code></dt>
<dd><p>Grantham&rsquo;s polarity and volume index.
</p></dd>
<dt><code>KleinCharge {AA}</code></dt>
<dd><p>Klein&rsquo;s charge.
</p></dd>
<dt><code>ChouFasmanAHelix, ChouFasmanBSheet, ChouFasmanTurn {AA}</code></dt>
<dd><p>Chou and Fasmani score for secondary structure prediction. 
</p></dd>
<dt><code>ChenGuHuangHydrophobicity {AA}</code></dt>
<dd><p>Hydrophobicity according to Chen, Gu and Huang.
</p></dd>
<dt><code>SEALow, SEAMedium, SEAHigh {AA}</code></dt>
<dd><p>Solvent Exposed Area, percent of amino acids having a SEA below 10,
between 10 and 30, or higher than 30, respectively.
</p></dd>
<dt><code>User</code></dt>
<dd><p>A user defined Index1, from a file in the AAIndex1 syntax. The input
file is specified using the <code>file={path}</code> argument.
<code>file</code>
</p>
</dd>
</dl>


<span id="Index2"></span><h4 class="subsection">3.4.2 Index2</h4>

<dl compact="compact">
<dt><code>None</code></dt>
<dd><p>If no index should be used.
</p></dd>
<dt><code>Blosum50 {AA}</code></dt>
<dd><p>The BLOSUM 50 amino acid distance matrix.
</p></dd>
<dt><code>Grantham, Miyata {AA}</code></dt>
<dd><p>Two biochemical distance matrices. Both accept an optional argument
<code>symmetrical={boolean}</code> allowing to specify if the matrix
should be symmetric or not. If not, the distance measure will be
signed.
</p></dd>
<dt><code>Diff</code></dt>
<dd><p>Allow to compute a distance matrix by taking the difference for, each
pair of state, of an Index1 value. The Index1 to use is specified
using the <code>index1={Index1 description}</code> argument. An
additional argument allow to specify whether the resulting matrix
should be symetric (<code>symmetrical={boolean}</code>): if so, the
absolute difference will be used. Alternatively, the distance will be
signed and d[i,j] = - d[j,i].
</p></dd>
<dt><code>User</code></dt>
<dd><p>A user defined Index2, from a file in the AAIndex2 syntax. The input
file is specified using the <code>file={path}</code> argument. The
<code>symmetrical={boolean}</code> argument can be used to specify
whether distances should be signed or not.
</p></dd>
</dl>




<hr>
<span id="Likelihoods"></span><div class="header">
<p>
Next: <a href="#Distribution" accesskey="n" rel="next">Distribution</a>, Previous: <a href="#AlphabetIndex" accesskey="p" rel="prev">AlphabetIndex</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Declaring-Phylo_002dlikelihoods"></span><h3 class="section">3.5 Declaring Phylo-likelihoods</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Model" accesskey="1">Model</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Markov model specification
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Root" accesskey="2">Root</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Root frequencies
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FrequenciesSet" accesskey="3">FrequenciesSet</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Frequencies 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rates" accesskey="4">Rates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Rates across sites
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Process" accesskey="5">Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Process along trees
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Phylo_002dlikelihoods" accesskey="6">Phylo-likelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Declaration of likelihoods
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linking" accesskey="7">Linking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Linking parameters
</td></tr>
</table>

<hr>
<span id="Model"></span><div class="header">
<p>
Next: <a href="#Root" accesskey="n" rel="next">Root</a>, Previous: <a href="#Likelihoods" accesskey="p" rel="prev">Likelihoods</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-up-the-substitution-models"></span><h4 class="subsection">3.5.1 Setting up the substitution models</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Nucleotide" accesskey="1">Nucleotide</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Nucleotide models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Protein" accesskey="2">Protein</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Protein models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous" accesskey="3">Miscellaneous</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Miscellaneous models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Codon" accesskey="4">Codon</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Codon models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Multiple" accesskey="5">Multiple</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">General multiple site models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Meta" accesskey="6">Meta</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Meta models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mixture" accesskey="7">Mixture</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Mixture of models
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conditioned" accesskey="8">Conditioned</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Models conditioned by events
</td></tr>
</table>

<dl compact="compact">
<dt><code>model{number} = {model description}</code></dt>
<dd><p>A description of a substitution model of a given number use, using the
keyval syntax.
</p>
</dd>
</dl>

<p>Many models have a set of optional parameters denoted here as
&quot;equilibrium frequencies&quot; that are used to initialize the parameters
of the model related with the equilibrium frequencies. These options
are:
</p>
<dl compact="compact">
<dt><code>initFreqs=values({real]0,1[},...,{real]0,1[})</code></dt>
<dd><p>The equilibrium frequency is set equal (as much as possible) to the
given frequencies. Those frequencies are given in the same order as
the alphabet, and they must sum 1.
</p>
</dd>
<dt><code>initFreqs=observed</code></dt>
<dd><p>The equilibrium frequency is set equal (as much as possible) to the
observed frequencies.
</p>
</dd>
<dt><code>initFreqs.observedPseudoCount={integer}</code></dt>
<dd><p>a peusocount integer added to all counts of letters (or words), when
the frequencies are computed from observed data.
</p>
</dd>
</dl>

<hr>
<span id="Nucleotide"></span><div class="header">
<p>
Next: <a href="#Protein" accesskey="n" rel="next">Protein</a>, Previous: <a href="#Model" accesskey="p" rel="prev">Model</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Nucleotide-models"></span><h4 class="subsubsection">3.5.1.1 Nucleotide models</h4>

<dl compact="compact">
<dt><code>JC69</code></dt>
<dd><p>The Jukes and Cantor model. This model has no additional parameter.
See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1JCnuc.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>K80([kappa={real&gt;0}])</code></dt>
<dd><p>The Kimura 2 parameters model. <var>kappa</var> is the transition over
transversion ratio. Default: <var>kappa</var>=1. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1K80.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>F84([kappa={real&gt;0}, theta={real]0,1[}, theta1={real]0,1[},theta2={real]0,1[}, &quot;equilibrium frequencies&quot;] )</code></dt>
<dd><p>Felsenstein&rsquo;s 1984 substitution model, with transition/transversion
ratio and 4 distinct equilibrium frequencies, set using three
independent parameters: <var>theta</var> is the GC content, <var>theta1</var> is
the proportion of G / (G + C) and <var>theta2</var> is the proportion of A
/ (A + T or U). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1F84.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>HKY85([kappa={real&gt;0}, theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Hasegawa, Kishino and Yano 1985&rsquo;s substitution model. The model is
similar to <code>F84</code>, but with a different implementation. The
<var>kappa</var> parameter used here is comparable to the one in
<code>K80</code>. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1HKY85.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>T92([kappa={real&gt;0}, theta={real]0,1[} ,&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Tamura 1992&rsquo;s model for nucleotides, similar to <code>HKY85</code>, yet
assuming that the frequencies of A = T/U and G = C. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1T92.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>TN93([kappa1={real&gt;0}, kappa2={real&gt;0}, theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Tamura and Nei 1993&rsquo;s model, similar to <code>HKY85</code>, but allowing
for two distinct transition/transversion ratios. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1TN93.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>GTR([a={real&gt;0}, b={real&gt;0}, c={real&gt;0}, d={real&gt;0}, e={real&gt;0}, theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[} ,&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>The General Time-Reversible substitution model. Parameters <var>a</var>,
<var>b</var>, <var>c</var>, <var>d</var>, <var>e</var> are the entries of the
exchangeability matrix. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1GTR.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>L95([beta={real&gt;0}, gamma={real&gt;0}, delta={real&gt;0}, theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[} ,&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>The strand-symmetric model of Lobry 1995, for nucleotides. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1L95.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>SSR([beta={real&gt;0}, gamma={real&gt;0}, delta={real&gt;0}, theta={real]0,1[}])</code></dt>
<dd><p>The strand-symmetric reversible model, for nucleotides. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1SSR.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>RN95([thetaR={real]0,1[}, thetaC={real]0,1[}, thetaG={real]0,1[}, kappaP={real[0,1[}, gammaP={real[0,1[}, sigmaP={real&gt;1}, alphaP={real&gt;1}])</code></dt>
<dd><p>The model described by Rhetsky and Nei, where the only hypothesis is
that the transversion rates are only dependent of the target
nucleotide. This model is not reversible. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1RN95.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>RN95s([thetaA={real]0,0.5[}, gamma={real]0,0.5[}, alphaP={real&gt;1}])</code></dt>
<dd><p>The instersection of models RN95 and L95. The two hypotheses are that
the transversion rates are only dependent of the target nucleotide,
and strand symmetry. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1RN95s.html#details">Bio++ description</a>.
</p>
</dd>
</dl>

<hr>
<span id="Protein"></span><div class="header">
<p>
Next: <a href="#Miscellaneous" accesskey="n" rel="next">Miscellaneous</a>, Previous: <a href="#Nucleotide" accesskey="p" rel="prev">Nucleotide</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Protein-models"></span><h4 class="subsubsection">3.5.1.2 Protein models</h4>

<dl compact="compact">
<dt><code>JC69</code></dt>
<dd><p>The Jukes and Cantor model. This model has no additional parameter. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1JCprot.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>DSO78</code></dt>
<dd><p>Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1DSO78.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>JTT92</code></dt>
<dd><p>Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1JTT92.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>WAG01</code></dt>
<dd><p>Protein substitution model, from Whelan &amp; Goldman 2001. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1WAG01.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LG08</code></dt>
<dd><p>Protein substitution model, from Le &amp; Gascuel 2008. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LG08.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LLG08_EX2([relrate1={real]0,1[}, relproba1={real]0,1[}])</code></dt>
<dd><p>Protein substitution model, from Le, Lartillot &amp; Gascuel 2008.
See <a href="#Mixture">Mixture</a>, for the meaning of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LLG08__EX2.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LLG08_EX3([relrate1={real]0,1[}, relrate2={real]0,1[}, relproba1={real]0,1[}, relproba2={real]0,1[}])</code></dt>
<dd><p>Protein substitution model, from Le, Lartillot &amp; Gascuel 2008. See <a href="#Mixture">Mixture</a>, for the meaning of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LLG08__EX3.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LLG08_EHO([relrate1={real]0,1[}, relrate2={real]0,1[}, relproba1={real]0,1[}, relproba2={real]0,1[}])</code></dt>
<dd><p>Protein substitution model, from Le, Lartillot &amp; Gascuel 2008. See <a href="#Mixture">Mixture</a>, for the meaning of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LLG08__EHO.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LLG08_UL2([relrate1={real]0,1[}, relproba1={real]0,1[}])</code></dt>
<dd><p>Protein substitution model, from Le, Lartillot &amp; Gascuel 2008. See <a href="#Mixture">Mixture</a>, for the meaning of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LLG08__UL2.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LLG08_UL3([relrate1={real]0,1[}, relrate2={real]0,1[}, relproba1={real]0,1[}, relproba2={real]0,1[}])</code></dt>
<dd><p>Protein substitution model, from Le, Lartillot &amp; Gascuel 2008. See <a href="#Mixture">Mixture</a>, for the meaning of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LLG08__UL3.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>LGL08_CAT(nbCat={[10,20,30,40,50,60]}, [relrate1={real]0,1[}, relrate2={real]0,1[}, ..., relproba1={real]0,1[}, relproba2={real]0,1[}, ...] ))</code></dt>
<dd><p>CAT protein substitution model, from Le, Gascuel &amp; Lartillot 2008, with a
given number (<var>nbCat</var>) of profiles. See <a href="#Mixture">Mixture</a>, for the meaning
of the variables. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LGL08__CAT.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>LGL08_CAT_C{[1,...,nbCat]}(nbCat={[10,20,30,40,50,60]})</code></dt>
<dd><p>Submodel of a given CAT Protein substitution model, from Le, Gascuel &amp;
Lartillot 2008, with a given number (<var>nbCat</var>) of profiles. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LGL08__CAT.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>DSO78+F([theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ... ,&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005 and free equilibrium frequencies. The <var>thetaX</var>
are frequencies parameters, where X is 1 to 19. Parameter <var>theta1</var>
is the proportion of A, <var>theta2</var> is the proportion of R over
(1-A), <var>theta3</var> the proportion of N over (1-A-R), etc. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1DSO78.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>JTT92+F([theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ..., &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005 and free equilibrium frequencies. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1JTT92.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>WAG01+F([theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ..., &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Protein substitution model, from Whelan &amp; Goldman 2001, and free
equilibrium frequencies. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1WAG01.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>LG08+F([theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ..., &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Protein substitution model, from Le &amp; Gascuel 2008, and free
equilibrium frequencies. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1LG08.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>Empirical(name={chars}, file={path})</code></dt>
<dd><p>Build a protein substitution model from a file in PAML format, and use
&rsquo;name&rsquo; as a namespace for parameters.
</p>
</dd>
<dt><code>Empirical+F(name={chars}, file={path}, [theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ..., &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Build a protein substitution model from a file in PAML format, and use
free equilibrium frequencies. &rsquo;name&rsquo; will be used as a parameter
namespace, including for frequencies.
</p>
</dd>
</dl>

<hr>
<span id="Miscellaneous"></span><div class="header">
<p>
Next: <a href="#Codon" accesskey="n" rel="next">Codon</a>, Previous: <a href="#Protein" accesskey="p" rel="prev">Protein</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Miscellaneous-models"></span><h4 class="subsubsection">3.5.1.3 Miscellaneous models</h4>

<dl compact="compact">
<dt><code>Binary([kappa={real&gt;0} ,&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Build the model on binary alphabet, where <var>kappa</var> is the relative
proportion of 1 over 0 in the equilibrium distribution. Default:
<var>kappa</var>=1. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1BinarySubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
</dl>

<dl compact="compact">
<dt><code>Equi([&quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Build the equiprobable model, between any set of states. See the
<a href="http://biopp.univ-montp2.fr/Documents/ClassDocumentation/bpp-phyl/html/classbpp_1_1EquiprobableSubstitutionModel.html#_details">Bio++ description</a>.
</p>
</dd>
</dl>

<hr>
<span id="Codon"></span><div class="header">
<p>
Next: <a href="#Multiple" accesskey="n" rel="next">Multiple</a>, Previous: <a href="#Miscellaneous" accesskey="p" rel="prev">Miscellaneous</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Codon-models"></span><h4 class="subsubsection">3.5.1.4 Codon models</h4>

<p>Some codon models also take as argument a <var>frequencies</var> option
specifying the equilibrium frequencies of the model. Any frequencies
description can be used here, but the syntax also supports options
similar to the ones used in the PAML software:
</p>
<ul>
<li> F0: all frequencies are assumed to be fixed and equal to 1/61, 0 for stop codons.
</li><li> F1X4: 4 distinct frequencies are used, with parameters theta, theta1, theta2 (See <a href="#Frequencies-sets">Frequencies sets</a>, &ldquo;Full&rdquo; method).
</li><li> F3X4: 4 distinct frequencies are used for each position, resulting in 9 parameters in total (3 independent &ldquo;Full&rdquo; frequencies set).
</li><li> F61: free equilibrium frequencies, stop codons set to 0.
</li></ul>

<p>An optional option <var>mgmtStopCodon</var> can be set to define how the
frequencies computed to stop codons in the case of F1X4 et F3X4 are
distributed to other codons.
</p>
<ul>
<li> uniform : each stop frequency is distributed evenly
</li><li> linear : each stop frequency is distributed to the neighbour
codons (ie 1 substitution away), in proportion to each target codon
frequency.
</li><li> quadratic (default): each stop frequency is distributed to the
neighbour codons (ie 1 substitution away), in proportion to the square
of each target codon frequency.
</li></ul>

<p>The same words can be used to specify root frequencies for codon
models, in the case of non stationarity.
</p>
<dl compact="compact">
<dt><code>GY94([kappa={real&gt;0}, V={real&gt;0}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Goldman and Yang (1994) substitution model for codons (default values:
<var>kappa</var>=1 and <var>V</var>=10000). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1GY94.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>MG94([rho={real&gt;0}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Muse and Gaut (1994) substitution model for codons (default values:
<var>rho</var>=1). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1MG94.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YN98([kappa={real&gt;0}, omega={real&gt;0}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Yang and Nielsen (1998) substitution model for codons (default values:
<var>kappa</var>=1 and <var>omega</var>=1). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YN98.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YNGP_M0([kappa={real&gt;0}, omega={real&gt;0}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>The M0 model of PAML, ie the same as YN98. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YN98.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YNGP_M1([kappa={real&gt;0}, omega={real&gt;0}, p0={real&gt;0 and &lt;1 }, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>The M1a model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000) (default values: <var>kappa</var>=1, <var>p0</var>=0.5,
<var>omega</var>=0.5). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YNGP__M1.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YNGP_M2([kappa={real&gt;0}, omega0={real&gt;0 and &lt;1}, theta1={real&gt;0 and &lt;1 }],  omega1={real&gt;1},  theta2={real&gt;0 and &lt;1 }, &quot;equilibrium frequencies&quot;])</code></dt>
<dd>
<p>The M2a model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with  p0=theta1  and
p1=(1-theta1)*theta2 (default values: <var>kappa</var>=1, <var>theta1</var>=0.33333,
<var>theta2</var>=0.5, <var>omega0</var>=0.5, <var>omega2</var>=0.5). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YNGP__M2.html#details">Bio++ description</a>.
</p>  

</dd>
<dt><code>YNGP_M3([n={integer&gt;0}, kappa={real&gt;0}, omega0={real&gt;0 and &lt;1}, delta1={real&gt;0}, ..., delta<var>n-1</var>={real&gt;0}, theta1={real&gt;0 and &lt;1 }, ..., theta<var>n-1</var>1={real&gt;0 and &lt;1 }, &quot;equilibrium frequencies&quot;])</code></dt>
<dd>
<p>The M3 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with <var>n</var> discrete values, with p0=theta1
and pk=(1-theta1)*...*(1-thetak)*theta(k+1), and
omegak=omega0+delta1+....+deltak (default values: <var>n</var>=3,
<var>kappa</var>=1, <var>thetak</var>=1/(n-k+1), <var>omega0</var>=0.5,
<var>deltak</var>=0.5). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YNGP__M3.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YNGP_M7(n={integer&gt;0}, kappa={real&gt;0}, p={real&gt;1}, q={real&gt;1 }, &quot;equilibrium frequencies&quot;])</code></dt>
<dd>
<p>The M7 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with the Beta distribution discretized in <var>n</var>
classes (default values: <var>kappa</var>=1, <var>p</var>=2, <var>q</var>=2). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YNGP__M7.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YNGP_M8(n={integer&gt;0}, [kappa={real&gt;0}, omegas={real&gt;1}, p0={real&gt;0},p={real&gt;1}, q={real&gt;1 }, &quot;equilibrium frequencies&quot;])</code></dt>
<dd>
<p>The M8 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with the Beta distribution discretized in <var>n</var>
classes (default values: <var>kappa</var>=1, <var>p</var>=2, <var>q</var>=2,
<var>p0</var>=0.5, <var>omegas</var>=2). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YNGP__M8.html#details">Bio++ description</a>.
</p>

</dd>
</dl>

<p>It is also possible to setup more specific models, by specifying a
nucleotide model for each position. Model parameters names then take
the form of &lt;codon model name&gt;.&lt;position set&gt;_&lt;position model
name&gt;.&lt;position specific parameter name&gt;.
</p>
<p>In the following models, the arguments <var>model</var> and
<var>model{i}</var> are for descriptions of models on bases.
</p>
<ul>
<li> If the argument is <var>model</var>, the <em>same</em> single site model is
used on all positions (ie the parameters are shared between all
positions).
</li><li> If the arguments are <var>model1</var>, <var>model2</var>, <var>model3</var>, each
single site model stands for a single-site substitution model. In that
case, all single site models parameters are position dependent.
</li></ul>

<p>Each single site model is normalized and the substitution rates
between codons that differ on more than one letter are null.
</p>
<p>The generator is first computed with these models and parameters on
the whole triplet alphabet, and then the substitution rates to and
from stop codons are set to zero and the generator is normalized with
this modification.
</p>
<p>The model names est defined through several words that can be mixed
together to build models at hand. Some words are exclusive. The
model description must begin with <var>Codon</var>.
</p>

<p><var>Rate</var> and <var>Prot</var> and <var>Dist</var> words define how the models
are mixed, either with specific rates, or using proteic models, or
with non-synonymous vs synonymous substitution rates. They are
exclusive, and one of the three must be used. The default model is
<var>Rate</var>.
</p>
<dl compact="compact">
<dt><code>Rate(model... [, relrate1={real&gt;0}, relrate2={real&gt;0}])</code></dt>
<dd>

<p>Substitution model on codons with position specific evolution rates.
</p>
<p>Arguments <var>relrate{i}</var> stands for the relative substitution rates
of the sites. Default: <var>relrate{i}=1/{4-i}</var>, such that the rate
of each site is 1/3.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
model=CodonRate(model=T92)
</pre></div>
</td></tr></table>

<p>builds a model on codons, such all sites follow the same T92 model.
The parameters names are <var>CodonRate.123_T92.kappa</var>,
<var>CodonRate.relrate1</var>, <var>CodonRate.relrate2</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
model=CodonRate(model1=T92, model2=T92, model3=JC69)
</pre></div>
</td></tr></table>

<p>builds a model on codons, such that first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are <var>CodonRate.1_T92.kappa</var>,
<var>CodonRate.2_T92.kappa</var>, <var>CodonRate.relrate1</var>,
<var>CodonRate.relrate2</var>, and can be initialized as is:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=CodonRate(model1=T92(theta=0.5, kappa=2), \
                model2=T92(theta=0.4, kappa=2), model3=JC69)
</pre></div>
</td></tr></table>

<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1CodonRateSubstitutionModel.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>Dist(model...[, beta={real&gt;0}])</code></dt>
<dd>
<p>Substitution model on codons that takes into account the difference
between synonymous and non-synonymous substitutions.
</p>
<p>Optional argument <var>beta</var> is the ratio between non-synonymous
substitution rate and synonymous substitution rate. Default value: 1.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
model=CodonDist(model=T92)
</pre></div>
</td></tr></table>

<p>builds a model on codons, such all sites follow the same T92 model.
The parameters names are <var>CodonDist.123_T92.kappa</var> and 
<var>CodonDist.beta</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA, type=Standard)
model=CodonDist(model1=T92, model2=T92, model3=JC69)
</pre></div>
</td></tr></table>

<p>builds a model on codons, such that first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are <var>CodonDist.1_T92.kappa</var>,
<var>CodonDist.2_T92.kappa</var>, <var>CodonDist.beta</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1CodonDistanceSubstitutionModel.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>Prot(model..., protmodel={proteic model name}[, beta={real&gt;0}])</code></dt>
<dd>
<p>Substitution model on codons that takes into account the substitution
rates in a protein model. Those rates are multiplied by a
non-synonymous susbtitution factor, aka <var>beta</var>.
</p>
<p><var>Prot</var> and <var>Dist</var> words are exclusive.
</p>

<p>Optional argument <var>beta</var> is the ratio between average substitution
rate between amino-acids and synonymous substitution rate. Default
value: 1.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
model=CodonProt(model=T92, protmodel=LG08)
</pre></div>
</td></tr></table>

<p>builds a model on codons, such all sites follow the same T92 model,
and amino-acid rates are proportional to LG08 substition matrice.
The parameters names are <var>CodonProt.123_T92.kappa</var> and 
<var>CodonProt.beta</var>.
</p>
</dd>
</dl>

<p>Optional words to describe the use of equilibrium frequencies
sets. This word should be used with nucleotidic models which
equilibrium distribution is fixed, ans does not depend on parameters.
Otherwise there may be problems of identifiability of the parameters.
</p>
<dl compact="compact">
<dt><code>Freq(frequencies={frequencies set description})</code></dt>
<dd>
<p>Sustitution rates are multiplied by the frequency of the target codon
in the given frequencies set. This factor is described by the
<var>frequencies</var> argument. See the description of the Frequencies Set
below.
</p>

<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
model=CodonDistFreq(frequencies=Full())
</pre></div>
</td></tr></table>

<p>has parameters <var>CodonDistFreq.012_T92.kappa</var>,
<var>CodonDistFreq.Full.theta_1</var>, ...,
<var>CodonDistFreq.Full.theta_60</var>,
<var>CodonDistFreq.beta</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1CodonDistanceFrequenciesSubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>PhasFreq(frequencies={frequencies set description})</code></dt>
<dd>
<p>The sustitution rates are multiplied by the product of the frequencies
of the changed nucleotides &ndash; conditioned on the phase &ndash; in the given
frequencies set. This factor is described by the <var>frequencies</var>
argument. See the description of the Frequencies Set below.
</p>

<p>For example, see the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1CodonDistancePhaseFrequenciesSubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
</dl>



<p>In addition some models are defined that allow multiple substitions,
with similar logic of included words. These models are prefixed by <var>Kron</var>.
</p>

<dl compact="compact">
<dt><code>KronDistFreq(model={model name} [,positions=pos1*pos2*...*posn + posx*...*posm + ...)])</code></dt>
<dt><code>KronDistFreq(model1={model name}, model1={model name}, ..., modeln={model name}[,positions=pos1*pos2*...*posn + posx*...*posm + ...])</code></dt>
<dd>
<p>substitution model on codons as <var>CodonDistFreq</var> above, allowing
simultaneous substitutions.
</p>
<p>Optional argument <var>positions</var> can be used to describe which
substitutions are allowed. See model See <a href="#Kron">Kron</a>.
</p>
</dd>
<dt><code>KronDist(model={model name} [,positions=pos1*pos2*...*posn + posx*...*posm + ...)])</code></dt>
<dt><code>KronDist(model1={model name}, model1={model name}, ..., modeln={model name}[,positions=pos1*pos2*...*posn + posx*...*posm + ...])</code></dt>
<dd>
<p>substitution model on codons as <var>CodonDist</var> above, allowing
simultaneous substitutions.
</p>
<p>Optional argument <var>positions</var> can be used to describe which
substitutions are allowed. See model See <a href="#Kron">Kron</a>.
</p>
</dd>
<dt><code>KCM7() and  KCM19()</code></dt>
<dd>
<p>Kronecker Codon Model based on a unique (KCM7) or one per position
(KCM19) GTR model. From Zaheri \&amp; al, MBE, 2014.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1KCM.html#details">Bio++ description</a>.
</p>


</dd>
</dl>


<hr>
<span id="Multiple"></span><div class="header">
<p>
Next: <a href="#Meta" accesskey="n" rel="next">Meta</a>, Previous: <a href="#Codon" accesskey="p" rel="prev">Codon</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="General-multiple-site-models"></span><h4 class="subsubsection">3.5.1.5 General multiple site models</h4>

<dl compact="compact">
<dt><code>Word(model={model name} [,relrate1={1&gt;real&gt;0}, ..., relrate{n-1}={1&gt;real&gt;0}])</code></dt>
<dd><p>or 
</p></dd>
<dt><code>Word(model1={model name}, model1={model name}, ..., modeln={model name}[, relrate1={1&gt; real&gt;0}, ..., relrate{n-1}={1&gt; real&gt;0}])</code></dt>
<dd>
<p>substitution model on words. The arguments <var>model</var> and
<var>model{i}</var> are for descriptions of models on single sites such
as nucleotides or proteins. The alphabet must be a Word alphabet.
</p>
<p>If the argument is <var>model</var>, the length of the words in the
substitution model is determined by the length of the words in the
alphabet, and the <em>same</em> single site model is used (ie the
parameters are shared between all positions).
</p>
<p>If the arguments are <var>model1</var>, ..., <var>model{n}</var>, the length
of the words in the alphabet must be <var>n</var>, and each single site
model stands for a single-site substitution model. In that case, all
single site models parameters are position dependent.
</p>
<p>Each single site model is normalized and the substitution rates
between words that differ on more than one letter are null.
</p>
<p>Arguments <var>relrate{i}</var> stands for the relative substitution rates
of the sites. Default: <var>relrate{i}=1/{n-i+1}</var>, such that the rate
of each site is 1/n.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Word(letter=DNA,length=4)
model=Word(model=T92())
</pre></div>
</td></tr></table>

<p>builds a model on 4 bases words, such all sites follow the same T92
model. The parameters names are <var>Word.1234_T92.kappa</var>,
<var>Word.relrate1</var>, <var>Word.relrate2</var>, <var>Word.relrate3</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Word(letter=DNA,length=4)
model=Word(model1=T92(), model2=T92(), model3=JC69(), \
           model4=HKY85())
</pre></div>
</td></tr></table>

<p>builds a model on 4 bases words, such first and second sites follow
independent T92 models, third site follows a JC69 model, and fourth
site follows a HKY85 model. Then the parameters names are
<var>Word.1_T92.kappa</var>, <var>Word.2_T92.kappa</var>,
<var>Word.4_HKY85.kappa</var>, <var>Word.4_HKY85.theta</var>,
<var>Word.4_HKY85.theta1</var>, <var>Word.4_HKY85.theta2</var>,
<var>Word.relrate1</var>, <var>Word.relrate2</var>, <var>Word.relrate3</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1WordSubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>Kron(model={model name} [,positions=pos1*pos2*...*posn + posx*...*posm + ...)])</code></dt>
<dd><span id="Kron"></span>
</dd>
<dt><code>Kron(model1={model name}, model1={model name}, ..., modeln={model name}[,positions=pos1*pos2*...*posn + posx*...*posm + ...])</code></dt>
<dd>
<p>substitution model on words, allowing simultaneous substitutions. The
arguments <var>model</var> and <var>model{i}</var> are for descriptions of
models on single sites such as nucleotides or proteins. The alphabet
must be a Word alphabet.
</p>
<p>If the argument is <var>model</var>, the length of the words in the
substitution model is determined by the length of the words in the
alphabet, and the <em>same</em> single site model is used (ie the
parameters are shared between all positions).
</p>
<p>If the arguments are <var>model1</var>, ..., <var>model{n}</var>, the length
of the words in the alphabet must be <var>n</var>, and each single site
model stands for a single-site substitution model. In that case, all
single site models parameters are position dependent.
</p>
<p>The rate of a multiple substitution is the product of the rates of the
single substitutions it is made of.
</p>
<p>Without optional argument <var>positions</var>, all single and multiple
substitutions are allowed.
</p>
<p>Optional argument <var>positions</var> describes the allowed substitutions.
It is written as a formula with positions between 1 and the length of
the word, and symbols &rsquo;*&rsquo; (to link positions that must change
together) and &rsquo;+&rsquo; (to link sets of multiple susbtitutions that are
allowed).
</p>
<p>As examples, on a DNA word with 3 positions:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=Kron(model=K80(), positions=1*2*3)
</pre></div>
</td></tr></table>
<p>allows only substitutions that change the 3 positions.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=Kron(model=K80(), positions=1*2+3)
</pre></div>
</td></tr></table>
<p>allows only substitutions that change the positions 1 and 2, and the
ones that change position 3 alone.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=Kron(model=K80(), positions=1*2+2*3)
</pre></div>
</td></tr></table>
<p>allows only substitutions that change two neighbor positions.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=Kron(model=K80(), positions=1+2+3)
</pre></div>
</td></tr></table>
<p>allows only substitutions that change one position, i.e. <var>Word</var>
model.
</p>

<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1KronSubstitutionModel.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>Triplet(model={model description} [, relrate1={real&gt;0}, relrate2={real&gt;0}])</code></dt>
<dd><p>or 
</p></dd>
<dt><code>Triplet(model1={model description}, model2={model description}, model3={model description}[, relrate1={real&gt;0}, relrate2={real&gt;0}])</code></dt>
<dd>
<p>substitution model on 3 letters words. The arguments <var>model</var> and
<var>model{i}</var> are for descriptions of models on single sites such as
nucleotides or proteins. The alphabet must be a 3-letters word
alphabet or a codon alphabet.
</p>
<p>If the argument is <var>model</var>, the <em>same</em> single site model is
used on all positions (ie the parameters are shared between all
positions).
</p>
<p>If the arguments are <var>model1</var>, <var>model2</var>, <var>model3</var>, each
single site model stands for a single-site substitution model. In that
case, all single site models parameters are position dependent.
</p>
<p>Each single site model is normalized and the substitution rates
between triplets that differ on more than one letter are null.
</p>
<p>Arguments <var>relrate{i}</var> stands for the relative substitution rates
of the sites. Default: <var>relrate{i}=1/{4-i}</var>, such that the rate
of each site is 1/3.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
model=Triplet(model=T92)
</pre></div>
</td></tr></table>
<p>builds a model on codons, such all sites follow the same T92 model.
The parameters names are <var>Triplet.123_T92.kappa</var>,
<var>Triplet.relrate1</var>, <var>Triplet.relrate2</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Word(letter=DNA, length=3)
model=Triplet(model1=T92, model2=T92, model3=JC69)
</pre></div>
</td></tr></table>
<p>builds a model on 3 bases words, such first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are <var>Triplet.1_T92.kappa</var>,
<var>Triplet.2_T92.kappa</var>, <var>Triplet.relrate1</var>,
<var>Triplet.relrate2</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1TripletSubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>YpR_Sym(model={model description}, [rCgT={real&gt;=0}, rTgC={real&gt;=0}, rCaT={real&gt;=0}, rTaC={real&gt;=0}])</code></dt>
<dd>
<p>substitution model on quotiented triplets to handle strand symetric
neighbour-dependency inside dinucleotides YpR (see Brard and Guguen
2012). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YpR_SymSubstitutionModel.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>YpR_Gen(model={model description}, [rCgT={real&gt;=0}, rcGA={real&gt;=0}, rTgC={real&gt;=0}, rtGA={real&gt;=0}, rCaT={real&gt;=0}, rcAG={real&gt;=0}, rTaC={real&gt;=0}, rtAG={real&gt;=0}])</code></dt>
<dd>
<p>substitution model on quotiented triplets to handle general symetric
neighbour-dependency inside dinucleotides YpR (see Brard and Guguen
2012). See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1YpR_GenSubstitutionModel.html#details">Bio++ description</a>.
</p>

</dd>
</dl>

<hr>
<span id="Meta"></span><div class="header">
<p>
Next: <a href="#Mixture" accesskey="n" rel="next">Mixture</a>, Previous: <a href="#Multiple" accesskey="p" rel="prev">Multiple</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Meta-models"></span><h4 class="subsubsection">3.5.1.6 Meta models</h4>

<p>These substitution models take as argument another substitution model, and add several parameters.
</p> 
<dl compact="compact">
<dt><code>TS98(model={model description}, s1={real&gt;0}, s2={real&gt;0} [, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Tuffley and Steel 1998&rsquo;s &rsquo;covarion&rsquo; model, taking a nested
substitution model as argument for <var>model</var>. The nested model can
be any substitution model for any alphabet. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1TS98.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>G01(model={model description}, rdist={rate distribution description}, mu={real&gt;0} [, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Galtier 2001&rsquo;s &rsquo;covarion&rsquo; model, taking a nested substitution model as
argument for <var>model</var> and a rate distribution for parameter
<var>rdist</var> (see below). The nested model can be any substitution
model for any alphabet. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1G01.html#details">Bio++ description</a>.
</p>

</dd>
<dt><code>RE08(model={model description}, lambda={real&gt;0}, mu={real&gt;0} [, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Rivas and Eddy 2008&rsquo;s substitution model with gaps, taking a nested
substitution model as argument for <var>model</var>. Parameter <var>lambda</var>
is the insertion rate, while <var>mu</var> is the deletion rate. See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1RE08.html#details">Bio++ description</a>.
</p>

</dd>
</dl>

<hr>
<span id="Mixture"></span><div class="header">
<p>
Next: <a href="#Conditioned" accesskey="n" rel="next">Conditioned</a>, Previous: <a href="#Meta" accesskey="p" rel="prev">Meta</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Mixture-of-models"></span><h4 class="subsubsection">3.5.1.7 Mixture of models</h4>

<dl compact="compact">
<dd>
<p>Mixed models are sometimes called &quot;site models&quot;.
</p>
<p>Mixed models combine substitution models with respective
probabilities. We call submodels all the models that are mixed in the
mixture. A Mixed model is either the mixture of several predefined
models, or based on a &quot;simple&quot; model in which some parameters follow
given distributions.
</p>
<p>During the likelihood computation process, all the submodels of the
mixture are successively applied on the branches, and the mean (see
below) of all the likelihoods is computed.
</p>
<p>A site can follow given paths all along the tree, with given
probabilities. 
</p>
<p>In homogeneous reconstruction, a path corresponds to a same submodel
on all the branches, in a stationary condition. The probability of a
path is the probability of its submodel. Given a site follows a path,
a likelihood can be computed; and the overall likelihood on this site
is the mean of these likelihoods (given the probabilities of the
paths). This means that the root distribution is a mixture of the
equilibrium distributions of the submodels.
</p>
<p>With nonhomogeneous reconstruction, several models are applied on the
tree, some models are mixed, some are not. A path is a vector which
size is the number of mixed models (see below for more details and the
declaration of paths). 
</p>
<p>Since the attribution of a submodel from a mixed model to a given site
is a unique random variable, affecting the same mixed model to a set
of branches S means that the attribution to this site is the same on
all the branches of S. If model M=(Ma,Mb,Mc) is defined on a set of
branches S, a site in constrained to follow either Ma on all S, or Mb
on all S, or Ms on all S. If we want that two branches of S are
independant, two similar mixed models must be defined. Moreover, it is
possible to define paths that define dependencies between submodels of
different mixtures (see below).
</p>

</dd>
<dt><code>MixedModel(model={model description})</code></dt>
<dd><p>Mixture model from a given <var>model</var> in which some parameters follow
a probabilistic distribution. Any discrete distribution available can
be used See <a href="#Discrete-distributions">Discrete distributions</a>. The description of the
parameters distributions is described below. In case the range of a
parameter is limited, the domain of the corresponding distribution is
truncated accordingly.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=MixedModel(model=TN93(kappa1=Gamma(n=4,alpha=3,beta=1),\
                            kappa2=Exponential(lambda=2),\
                            theta=0.5,theta1=0.2,theta2=0.1))
</pre></div>
</td></tr></table>
<p>has parameters <var>TN93.kappa1_Gamma.alpha</var>,
<var>TN93.kappa1_Gamma.beta</var>,
<var>TN93.kappa2_Exponential.lamba</var>,
<var>TN93.theta</var>, <var>MixedModel.TN93.theta1</var>,
<var>TN93.theta2</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1MixtureOfASubstitutionModel.html#details">Bio++ description</a>.
</p>
</dd>
<dt><code>Mixture(model1={model description},..., modeln={model description} [, relrate1={1&gt;real&gt;0},..., relrate{n-1}={1&gt;real&gt;0}, relproba1={1&gt;real&gt;0}, ..., relproba{n-1}={1&gt;real&gt;0}, &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Mixture model built from several <var>models</var>: each model has its own
probability and rate. 
</p>
<p>Arguments <var>relproba{i}</var> stands for the relative probability and
<var>relrate{i}</var> stands for the relative rate of each model (in the
order the models are given). Default: <var>relproba{i}=1/{n-i+1}</var>,
such that the probabilty of each site is 1/n, and
<var>relrate{i}=1/{n-i+1}</var> such that the rate of each site is 1.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=Mixture(model1=GY94(), model2=YN98(), relrate1=0.1)
</pre></div>
</td></tr></table>
<p>has parameters<var>Mixture.relrate1</var>, <var>Mixture.relproba1</var>,
<var>Mixture.1_GY94.kappa</var>, <var>Mixture.1_GY94.V</var>,
<var>Mixture.2_YN98.kappa</var>, <var>Mixture.2_YN98.omega</var>.
</p>
<p>See the
<a href="http://bioweb.me/bpp-phyl-doc/classbpp_1_1MixtureOfSubstitutionModels.html#details">Bio++ description</a>.
</p>
</dd>
</dl>

<span id="Paths-among-non_002dhomogeneous-mixture-models"></span><h4 class="subsubsection">3.5.1.8 Paths among non-homogeneous mixture models</h4>

<p>To define constraints for sites between submodels, we can set &quot;paths&quot;
and &quot;scenarios&quot;. A path is a succession of submodels a site may follow
down the tree, and scenarios are the sets of paths among which sites
must choose.
</p>
<div class="example">
<pre class="example">

model1=T92()
model2=MixedModel(model=T92(kappa=Simple(values=(4,10,20),probas=(0.1,0.5,0.4))))
model3=MixedModel(model=TN93(theta1=Simple(values=(0.1,0.5,0.9),probas=(0.3,0.2,0.5))))

process1=NonHomogeneous(model1=1, model1.nodes_id=0:1, model2=2, model2.nodes_id=2:3, model3=3, model3.nodes_id=4:5, tree=1, rate=1, root_freq=2)

</pre></div>

<p>In this case, on branches 2 &amp; 3 a site follows any submodel of model 2
(independently between the branches), and on branches 4 &amp; 5, a site
follows any submodel of model 3 (indenpendently between the branches).
Also, there is no constraint between models 2 &amp; 3, which means that a
site can follow any submodel of model 2 and any submodel of model 3.
</p>
<p>If the user wants that a site follows the same submodel of model 2 for
both branches, defines it in paths and a scenario:
</p>
<div class="example">
<pre class="example">

path1 = model2[1]
path2 = model2[2]
path3 = model2[3]

scenario1 = path1 &amp; path2 &amp; path3

process1=NonHomogeneous(model1=1, model1.nodes_id=0:1, model2=2,
model2.nodes_id=2:3, model3=3, model3.nodes_id=4:5, tree=1, rate=1,
root_freq=2, scenario = 1)

</pre></div>

<p>Similar description:
</p>
<div class="example">
<pre class="example">

path1 = model2[T92.kappa_1]
path2 = model2[T92.kappa_2]
path3 = model2[T92.kappa_3]

</pre></div>

<p>In this case, since model2 is totally split, it is possible to make it
shorter:
</p>
<div class="example">
<pre class="example">

scenario1 = split(model=2)

process1=NonHomogeneous(model1=1, model1.nodes_id=0:1, model2=2,
model2.nodes_id=2:3, model3=3, model3.nodes_id=4:5, tree=1, rate=1,
root_freq=2, scenario = 1)

</pre></div>

<p>Paths can be used to make combination of submodels between several
models. For example:
</p>
<div class="example">
<pre class="example">path1=model2[T92.kappa_1] &amp; model3[TN93.theta1_2]
path2=model2[T92.kappa_2] &amp; model3[TN93.theta1_3]
</pre></div>

<p>or, similar, because there is only one mixture in each model:
</p>
<div class="example">
<pre class="example">path1=model2[1] &amp; model3[2]
path2=model2[2] &amp; model3[3]
</pre></div>


<p>The third path (for the remaining submodels) is automatically
computed in the scenario, with <var>complete</var>:
</p>
<div class="example">
<pre class="example">scenario1 = path1 &amp; path2 &amp; complete
</pre></div>

<p>It is possible to link mixtures of submodels. For example,
</p>
<div class="example">
<pre class="example">path1=model2[T92.kappa_1] &amp; model3[TN93.theta1_2] &amp; model3[TN93.theta1_3]
</pre></div>

<p>means that a site that has <var>T92.kappa=4</var> in model2 has either
<var>TN93.theta1=0.5</var> or <var>TN93.theta1=0.9</var> in model3.
</p>

<p>Because of these constraints, the probabilities of the submodels are
linked. In the first example, probability of <var>T92.kappa=4</var> in
model 2 equals the probability of <var>TN93.theta1=0.5</var> in model 3.
Since it is contradictory with the probabilities originally defined in
models 2 or 3, the reference probabilities are the ones of the first
numbered mixed model, here model 2. In this case, the probabilities in
model 3 may have no use, but with the second example the probability
of submodel T92.kappa=4 equals the sum of the probabilities of
submodels TN93.theta1=0.5 or TN93.theta1=0.9. The relative proportion
of those models used in the declaration of model 3 is then used. Here
their respective probabilities are then: 0.1*0.2/ (0.2+0.5)=0.0286 and
0.1*0.5/(0.2+0.5)=0.0714.
</p>
<p>Concerning the optimization procedure, this choice may entail the non-
identifiability of several parameters (here the probabilities in model
3), so the user should be careful about this. 
</p>
<p>When the submodel is aliased behind a model name, the paths should be
defined as combinations of the model that is mixed. For example,
YNGP_M2 is made of 3 YN98 models, depending of three <var>omega</var>
values: &lt;1, =1, &gt;1. If we want a site to switch between &lt;1 and &gt;1
omega values between two sets of branches:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">

model1=YNGP_M2(frequencies=F1X4)
model2=YNGP_M2(frequencies=F1X4)

path1=model1[YN98.omega_1] &amp; model2[YN98.omega_3]
path2=model1[YN98.omega_2] &amp; model2[YN98.omega_2]
path3=model1[YN98.omega_3] &amp; model2[YN98.omega_1]

scenario1 = path1 &amp; path2 &amp; path3
</pre></div>
</td></tr></table>

<p>Another example in the case of mixtures of mixed models, where the
submodels are defined by their names;
</p>
<div class="example">
<pre class="example">

model1=LLG08_UL2()
model2=LLG08_UL3()

path1=model1[LLG08_UL2.M2] &amp; model2[LLG08_UL3.Q1]
path2=model1[LLG08_UL2.M1] &amp; model2[LLG08_UL3.Q2] &amp; model2[LLG08_UL3.Q3]
</pre></div>

<p>or, if the user does not know the names of the submodels:
</p>
<div class="example">
<pre class="example">

model1=LLG08_UL2()
model2=LLG08_UL3()

path1=model1[2] &amp; model2[1]
path2=model1[1] &amp; model2[2] &amp; model2[3]
</pre></div>

<p>When process definition <samp>OnePerBranch</samp>, each site is
constrained to follow the same submodel from leaves to root.
</p>
<hr>
<span id="Conditioned"></span><div class="header">
<p>
Previous: <a href="#Mixture" accesskey="p" rel="prev">Mixture</a>, Up: <a href="#Model" accesskey="u" rel="up">Model</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Conditioned-models"></span><h4 class="subsubsection">3.5.1.9 Conditioned models</h4>

<p>The transition probabilities on the branches are conditioned by the
occurence of given events. The model is then no-markovian, but
semi-markovian. The sets of considered events follow the one (ie
register) defined for substitution mapping (see the testnh manual).
</p>
<dl compact="compact">
<dt><code>OneChange(model={model description})</code></dt>
<dd><p>The transition probabilities along each branch are conditioned by the
fact that there has been at least one substitution on this branch with
thid model.
</p>
</dd>
<dt><code>OneChange(model={model description}, register={register</code></dt>
<dd><p>name}, numReg=num1+num2+...)
</p>
<p>The transition probabilities along each branch are conditioned by the
fact that there has been on this branch at least one substitution
of the specific types in the register. The &quot;+&quot; permits the declaration
of several types.
</p>
</dd>
</dl>

<hr>
<span id="Root"></span><div class="header">
<p>
Next: <a href="#FrequenciesSet" accesskey="n" rel="next">FrequenciesSet</a>, Previous: <a href="#Model" accesskey="p" rel="prev">Model</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-up-the-root-frequencies"></span><h4 class="subsection">3.5.2 Setting up the root frequencies</h4>

<p>Several root frequencies can be defined in the following way:
</p>
<dl compact="compact">
<dt><code>root_freq{number}={frequency set description}</code></dt>
</dl>

<p>The Frequencies set used can be any of the ones described below
See <a href="#Frequencies-sets">Frequencies sets</a>, depending on the alphabet used.
</p>

<hr>
<span id="FrequenciesSet"></span><div class="header">
<p>
Next: <a href="#Rates" accesskey="n" rel="next">Rates</a>, Previous: <a href="#Root" accesskey="p" rel="prev">Root</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Declaring-frequencies-sets"></span><h4 class="subsection">3.5.3 Declaring frequencies sets</h4>
<span id="Frequencies-sets"></span>
<p>The following frequencies distributions are available:
</p>
<dl compact="compact">
<dt><code>Fixed()</code></dt>
<dd><p>All frequencies are fixed to their initial value and are not
estimated. 
</p>
</dd>
<dt><code>GC(theta={real]0,1[})</code></dt>
<dd><p>For nucleotides only, set the G content equal to the C content.
</p>
</dd>
<dt><code>Full(theta1={real]0,1[}, theta2={real]0,1[}, ..., thetaN={real]0,1[})</code></dt>
<dd><p>Full parametrization. Contains N free parameters, where N is equal to
the size of the alphabet - 1. For codon models, N is the size of the
alphabet - 1 - the number of stop codons, whose frequencies are set to
0. For nucleotide sequences, theta is the GC content, theta1 is the
proportion of A over A+T, and theta2 is the proportion of G over G+C.
</p>
</dd>
<dt><code>Empirical(file={path} [,col={int}])</code></dt>
<dd><p>Read frequencies from a file. Each frequencies is set as plain column
in the file. If several columns are in the file, the number of the
column can be given with {col} argument (default: 1).
</p>
</dd>
<dt><code>Empirical+F(name={chars}, file={path}, [theta={real]0,1[}, theta1={real]0,1[}, theta2={real]0,1[}, ..., &quot;equilibrium frequencies&quot;])</code></dt>
<dd><p>Build a protein substitution model from a file in PAML format, and use
free equilibrium frequencies. &rsquo;name&rsquo; will be used as a parameter
namespace, including for frequencies.
</p>

</dd>
<dt><code>Word(frequency={frequency set description})</code></dt>
<dd>
<p>or 
</p>
</dd>
<dt><code>Word(frequency1={frequency set description}, frequency2={frequency set description}, ..., frequencyn={frequency set description})</code></dt>
<dd>
<p>frequencies on words computed as the product of frequencies on the
letters. The arguments <var>frequency</var> and <var>frequency{i}</var> are
for descriptions of frequency sets on single sites such as nucleotides
or proteins. The alphabet must be a Word alphabet.
</p>
<p>If the argument is <var>frequency</var>, the number of multiplied single
site frequencies is the length of the words in the alphabet, and the
<em>same</em> single site frequency set is used (ie the parameters are
shared between all positions).
</p>
<p>If the arguments are <var>frequency1</var>, ..., <var>frequency{n}</var>, the
length of the words in the alphabet must be <var>n</var>, and all single
site frequency sets are independent. In that case, all single site
frequency set parameters are position dependent.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Word(letter=DNA,length=4)
nonhomogeneous.root_freq=Word(frequency=GC())
</pre></div>
</td></tr></table>
<p>builds a root frequency set on 4 bases words, such that all sites
frequencies follow the same GC frequency set model. The parameter
name is <var>1234_GC.theta</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Word(letter=DNA,length=4)
nonhomogeneous.root_freq=Word(frequency1=GC(),frequency2=GC(),\
                      frequency3=Fixed(),frequency4=Full())
</pre></div>
</td></tr></table>
<p>builds a root frequency set on 4 bases words, such first and second sites
follow independent GC frequency sets, third site follows a Fixed
frequency set, and fourth site follows a Full frequency set. Then the
parameters names are <var>1_GC.theta</var>,
<var>2_GC.theta</var>, <var>4_Full.theta_1</var>,
<var>4_Full.theta_2</var>, <var>4_Full.theta_3</var>.
</p>
</dd>
<dt><code>Codon(frequency={frequency set description})</code></dt>
<dd>
<p>or 
</p>
</dd>
<dt><code>Codon(frequency1={frequency set description}, frequency2={frequency set description}, frequency3={frequency set description})</code></dt>
<dd>
<p>frequencies on codons computed as the product of frequencies on the
letters, with stop codon frequencies set to zero. The arguments
<var>frequency</var> and <var>frequency{i}</var> are for descriptions of
frequency sets on nucleotides. The alphabet must be a Codon alphabet.
</p>
<p>If the argument is <var>frequency</var>, the <em>same</em> single site
frequency set is used (ie the parameters are shared between all
positions).
</p>
<p>If the arguments are <var>frequency1</var>, <var>frequency2</var>,
<var>frequency3</var>, all single site frequency sets are independent. In
that case, all single site frequency set parameters are position
dependent.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
nonhomogeneous.root_freq=Codon(frequency=GC())
</pre></div>
</td></tr></table>
<p>builds a frequency set on codons, such that all sites frequencies
follow the same GC frequency set model. The parameter name is
<var>123_GC.theta</var>.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">alphabet=Codon(letter=DNA)
genetic_code=Standard
nonhomogeneous.root_freq=Codon(frequency1=GC(),frequency2=GC(),\
                               frequency3=Fixed())
</pre></div>
</td></tr></table>

<p>builds a frequency set on codons, such that first and second sites
follow independent GC frequency sets, third site follows a Fixed
frequency set. Then the parameters names are <var>1_GC.theta</var>,
<var>2_GC.theta</var>.
</p>

<p>Predefined codon frequencies are available, with a syntax similar to
the one used in the PAML software. See above Codon Models section.
</p>
</dd>
</dl>

<p>All functions accept the following arguments, that take priority over
the parameter specification:
</p>
<dl compact="compact">
<dt><code>init={balanced,observed}</code></dt>
<dd><p>Set all frequencies to the same value, or to their observed counts.
</p>
</dd>
<dt><code>observedPseudoCount={integer}</code></dt>
<dd><p>If the frequencies are set from observed counts, a pseudoCount is
added to all the counts.
</p>
</dd>
<dt><code>values=({vector&lt;double&gt;})</code></dt>
<dd><p>Explicitly set all frequencies manually. The size of the input vector
should equal the number of resolved states in the alphabet, be in
alphabetical order of states, and sum to one.
</p>
</dd>
</dl>

<hr>
<span id="Rates"></span><div class="header">
<p>
Next: <a href="#Process" accesskey="n" rel="next">Process</a>, Previous: <a href="#FrequenciesSet" accesskey="p" rel="prev">FrequenciesSet</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-up-substitution-rates"></span><h4 class="subsection">3.5.4 Setting up substitution rates</h4>

<p>Rate distributions are defined in the following way:
</p><dl compact="compact">
<dt><code>rate{number} = {rate distribution description}</code></dt>
</dl>

<p>The rate distribution is set to have a mean of 1.
The following distributions are currently available:
</p>
<dl compact="compact">
<dt><code>Constant</code></dt>
<dd><p>Uses a constant rate across sites.
</p>
</dd>
<dt><code>Gamma(n={int&gt;=2}, alpha={float&gt;0})</code></dt>
<dd><p>A discretized gamma distribution of rates, with <var>n</var> classes, and a
given shape, with mean 1 (scale=shape).
</p>
</dd>
<dt><code>Invariant(dist={rate distribution description}, p={real[0,1]})</code></dt>
<dd><p>A composite distribution allowing a special class of invariant site,
with a probability <var>p</var>.
</p>
</dd>
</dl>

<hr>
<span id="Process"></span><div class="header">
<p>
Next: <a href="#Phylo_002dlikelihoods" accesskey="n" rel="next">Phylo-likelihoods</a>, Previous: <a href="#Rates" accesskey="p" rel="prev">Rates</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-up-the-process"></span><h4 class="subsection">3.5.5 Setting up the process</h4>

<p>There are two kinds of processes, site substitution process and
sequence substitution processes. 
</p>

<p>Site substitution processes are numbered like this:
</p>
<dl compact="compact">
<dt><code>process{number} = {Homogeneous|OnePerBranch}(tree={number}, model={number}, rate={number} [, root_freq={number}])</code></dt>
<dt><code>process{number} = {NonHomogeneous}(tree={number}, model{number}={number}, model{number}.nodes_id=({number},...,{number}), rate={number} [, root_freq={number}])</code></dt>
<dt><code>process{number} = {OnePerBranch}(tree={number}, model{number}={number},</code></dt>
<dd><p>rate={number} [, root_freq={number},
                         shared_parameters={vector of {list&lt;chars&gt;}, {list&lt;chars&gt;_[list&lt;int&gt;]}}]) 
</p>
</dd>
</dl>

<p>The <code>Homogeneous</code> type is used for homogeneous process. The
<code>OnePerBranch</code> type is used for setting branch models (for
instance Galtier and Gouy 97 for branch GC content, or PAML branch
model), and the <code>NonHomogeneous</code> type for the more general
case, including PAML clade models.
</p>
<p>With <code>OnePerBranch</code>, the model is cloned to have one
independent model per branch. Optional argument
<samp>shared_parameters</samp> is the vector of model parameters that are
shared by all branches, or by a set of branches, defined by nodes ids
between brackets.
</p>

<p>With <code>NonHomogeneous</code> option, several models can be declared
in the process, using successive model index (starting with 1), and
assigning specific nodes id to each model. For example:
</p>
<div class="example">
<pre class="example">process=NonHomogeneous(tree=1, model1=3, model1.nodes_id=(0:2,4,7:8), model2=5, model2.nodes_id=(3,5,6), rate=1, root_freq=2)
</pre></div>

<p>Key words <samp>All</samp>, <samp>Leaves</samp>, and <samp>NoLeaves</samp>
(explicit meaning) can be used for nodes id.
</p>

<p>If <samp>root_freq</samp> is not declared, the process is assumed
stationary. In case of non-homogeneity, the used root frequencies is
the equilibrium frequency of the first model. When this model is a
mixture model, since there is not a set of equilibrium frequencies,
the root frequencies are set to be the average (with the respective
probabilities of the submodels) of the equilibrium frequencies of the
submodels.
</p>
<p>When the rate is discretized in several substitution classes, a
specific class can be as the rate of the process.
</p>
<p>For example, here is the declaration of a stationary non-homogeneous
process in which the rate is the second discrete value of the
discretized gamma distribution.
</p>
<div class="example">
<pre class="example">rate_distribution1 = Gamma(n=4)

process2=NonHomogeneous(model1=1,model1.nodes_id=(1:4,6:9),model2=2,model2.nodes_id=5,tree=2,rate=1.2)
</pre></div>


<p>Sequence substitution processes set up an organization of site
substitution processes along the sequence. 
</p>
<dl compact="compact">
<dt><code>process{number} = Mixture(process{number}={number},[probas=({vector of process probabilities})])</code></dt>
<dd>
<div class="example">
<pre class="example">process2=NonHomogeneous(...)
process5=Homogeneous(...)

process7=Mixture(process1=2, process2=5, probas=(0.3,0.7))
</pre></div>

<p>Each site substitution process has its own a priori probability; all
site substitution processes are enumerated, and all probabilities can
be given as a vector (must sum one). The likelihood on a site is
independent of other sites, and is the average value of the
likelihoods of all processes, given their a priori probabilities.
</p>
</dd>
<dt><code>process{number} = AutoCorr(process{number}={number},[probas=({vector of autocorrelation probabilities})])</code></dt>
<dd>
<p>Along the sequence, the site substitution processes are
autocorrelated, which makes the whole process (along sites and time)
an Hidden Markov Model, where the transition probilities from a
specific process to the other ones are equal. The likelihood on a site
is computed using the forward algorithm of HMM modelling. The within
process transition probabilities can be given as a vector.
</p>
<div class="example">
<pre class="example">process2=NonHomogeneous(...)
process5=Homogeneous(...)

process7=AutoCorr(process1=2, process2=5, probas=(0.95,0.9))
</pre></div>

</dd>
<dt><code>process{number} = HMM(process{number}={number},[probas=({vector of ({vector of process transition probabilities})})])</code></dt>
<dd>
<p>The probabilities of the processes on the sites are dependent in a
markovian way, which makes the whole process (along sites and time) an
Hidden Markov Model. The likelihood on a site is computed using the
forward algorithm of HMM modelling. The transition probabilities can
be given as a vector of lines of the transition matrix, each being
given as a vector.
</p>
<div class="example">
<pre class="example">process2=NonHomogeneous(...)
process5=Homogeneous(...)
process3=NonHomogeneous(...)

process7=HMM(process1=2, process2=5, process3=3, probas=((0.95,0.01,0.04),(0.1,0.8,0.1),(0.1,0.03,0.87)))
</pre></div>

</dd>
<dt><code>process{number} = Partition(process{number}={number},process{number}.sites=({number},...,{number}))</code></dt>
<dd>
<p>The site substitution processes are organized as a partition along the
sequence. The sites of the processes are defined as a list with ranges.
</p>
<div class="example">
<pre class="example">process2=NonHomogeneous(...)
process5=Homogeneous(...)

process7=Partition(process1=2, process2=5, process1.sites=(1,5:20,24-35), process2.sites=(2-4,21:23,36-50))
</pre></div>

</dd>
</dl>


<hr>
<span id="Phylo_002dlikelihoods"></span><div class="header">
<p>
Next: <a href="#Linking" accesskey="n" rel="next">Linking</a>, Previous: <a href="#Process" accesskey="p" rel="prev">Process</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Setting-up-phylo_002dlikelihoods"></span><h4 class="subsection">3.5.6 Setting up phylo-likelihoods</h4>

<p>A phylo-likelihood is an object defined by a data and a site or
sequence substitution process. The recursivity of the computation is
used as the name of the phylo-likelihood.
</p>
<dl compact="compact">
<dt><code>phylo{number}={Single|Double}(data={number}, process={number})</code></dt>
</dl>

<p>with <var>number</var> at least one.
</p>
<p>With optional parameter <var>useLog=yes</var>, the computation is done using log
(default: false). 
</p>

<p>When several phylo-likelihoods are declared, they can be mixed in an
mathematical, which result function will be computed (and
optimized). For examples:
</p>
<div class="example">
<pre class="example">result= (phylo1 + phylo2) / (phylo3 - phylo4)
result= (phylo1 + phylo2) / (phylo3 - phylo4)
result= (phylo1 + phylo2) / (phylo3 - phylo4)
</pre></div>

<p>Any parenthesized arithmetic formula is available, plus exp and log
functions.
</p>
<p>If <code>result</code> is not given, the default result is the sum of the
values of all the phylo-likelihoods.
</p>


<hr>
<span id="Linking"></span><div class="header">
<p>
Previous: <a href="#Phylo_002dlikelihoods" accesskey="p" rel="prev">Phylo-likelihoods</a>, Up: <a href="#Likelihoods" accesskey="u" rel="up">Likelihoods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Linking-parameters"></span><h4 class="subsection">3.5.7 Linking parameters</h4>

<p>It is possible to reduce the parameter space by putting extra
constraints on parameters, using for instance
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model=TN93(kappa1=1.0, kappa2=kappa1, theta=0.5)
</pre></div>
</td></tr></table>

<p>In that particular case the resulting model is strictly equivalent to
the HKY85 model. This syntax however allows to define a larger set of
models.
</p>
<p>As long as their range match, parameters of several objects (models,
root frequencies, rates, etc) can be linked.
</p>
<p>For instance:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model1 = T92(theta=GC.theta, kappa=3)
model2 = T92(theta=0.39, kappa=T92.kappa_1)
</pre></div>
</td></tr></table>

<p>Parameters can be linked between objects in the usual way (see
see <a href="#Linking">Linking</a>), or using <code>likelihood.alias</code>, for example to
linked branch lengths.
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">likelihood.alias= BrLen3_2-&gt; BrLen0_1, BrLen3_2-&gt; BrLen1_1
</pre></div>
</td></tr></table>

<p>where each alias is described as &lsquo;param1-&gt;param2&rsquo;. The full name of
the parameters have to be used, see for example:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model1 = T92(theta=0.4, kappa=4)
model2 = GTR(theta=0.4, a = 1.1, b=0.4, c=0.4, d=0.25, e=0.1)
likelihood.alias=GTR.theta1_2-&gt;T92.theta1_1
</pre></div>
</td></tr></table>

<p>This option can be used to link parameters of the root frequencies:
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">model1=GTR(theta1=0.7)
root_freq1=Full(init=balanced)
likelihood.alias=Full.theta1_1-&gt;GTR.theta1_1
</pre></div>
</td></tr></table>

<hr>
<span id="Distribution"></span><div class="header">
<p>
Next: <a href="#Estimation" accesskey="n" rel="next">Estimation</a>, Previous: <a href="#Likelihoods" accesskey="p" rel="prev">Likelihoods</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Discrete-distributions-1"></span><h3 class="section">3.6 Discrete distributions</h3>
<span id="Discrete-distributions"></span>
<p>Bio++ contains several probability distributions (currently only
dicrete or discretized ones). These are:
</p>
<span id="Standard-Distributions"></span><h4 class="subsection">3.6.1 Standard Distributions</h4>

<dl compact="compact">
<dt><code>Constant(value={float})</code></dt>
<dd><p>a Dirac distribution on <var>value</var>, with parameter <var>value</var>.
</p>
</dd>
<dt><code>Beta(n={int&gt;=2}, alpha={float&gt;0}, beta={float&gt;0})</code></dt>
<dd><p>a discretized beta distribution, with <var>n</var> classes, with standard
parameters <var>alpha</var> and <var>beta</var>.
</p>
</dd>
<dt><code>Gamma(n={int&gt;=2}, alpha={float&gt;0}, beta={float&gt;0})</code></dt>
<dd><p>a discretized gamma distribution, with <var>n</var> classes, a shape
<var>alpha</var> and a rate <var>beta</var>, with parameters <var>alpha</var> and
<var>beta</var>.
</p>
</dd>
<dt><code>Gaussian(n={int&gt;=1}, mu={float}, sigma={float&gt;0})</code></dt>
<dd><p>a discretized gaussian distribution, with <var>n</var> classes, a mean
<var>mu</var> and a standard deviation <var>sigma</var>, with parameters
<var>mu</var> and <var>sigma</var>.
</p>
</dd>
<dt><code>Exponential(n={int&gt;=2}, lambda={float&gt;0})</code></dt>
<dd><p>a discretized exponential distribution, with <var>n</var> classes and
parameter <var>lambda</var>.
</p>
</dd>
<dt><code>Simple(values={vector&lt;double&gt;}, probas={vector&lt;double&gt;} [, ranges={vector&lt;parametername[min;max]&gt;}])</code></dt>
<dd><p>a discrete distribution with specific values (in <var>values</var>) and
their respective non-negative probabibilities (in <var>probas</var>). The
parameters are <var>V1</var>, <var>V2</var>, ..., <var>Vn</var> for all the values
and the relative probabibility parameters are <var>theta1</var>,
<var>theta2</var>, ..., <var>thetan-1</var>. Optional argument {ranges} sets
the allowed ranges of values taken by the parameters; usage is like
&lsquo;<samp>ranges=(V1[0.2;0.9],V2[1.1;999])</samp>&rsquo;.
</p>
</dd>
<dt><code>TruncExponential(n={int&gt;=2}, lambda={float&gt;0}, tp={float&gt;0})</code></dt>
<dd><p>a discretized truncated exponential distribution, with <var>n</var>
classes, parameter <var>lambda</var> and a truncation point <var>tp</var>. The
parameters are <var>lambda</var> and <var>tp</var>.
</p>
</dd>
<dt><code>Uniform(n={int&gt;=1}, begin={float&gt;0}, end={float&gt;0})</code></dt>
<dd><p>a uniform distribution, with <var>n</var> classes in interval
[<var>begin</var>,<var>end</var>]. There are no parameters.
</p>
</dd>
</dl>

<span id="Mixture-Distributions"></span><h4 class="subsection">3.6.2 Mixture Distributions</h4>

<dl compact="compact">
<dt><code>Invariant(dist={distribution description}, p={float&gt;0})</code></dt>
<dd>
<p>a Mixture of a given discrete distributution and a 0 Dirac. <var>p</var> is
the probability of this 0 Dirac.
</p>
<p>For example :
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">Invariant(dist=Gaussian(n=4,2,0.5),p=0.1)
</pre></div>
</td></tr></table>
<p>builds a mixture of a gaussian distribution with 4 categories (and
probability 0.9) and a 0 Dirac with probability 0.1. Overall, there
are 5 categories. The parameters names are
<var>Invariant.Gaussian.mu</var>, <var>Invariant.Gaussian.sigma</var>,
<var>Invariant.p</var>.
</p>
</dd>
<dt><code>Mixture(probas={vector&lt;double&gt;}, dist1={distribution description}, ..., distn={distribution description})</code></dt>
<dd>
<p>a Mixture of discrete distributions with specific probabilities (in
<var>probas</var>) and their respective desccriptions (in <var>probas</var>).
The parameters are the relative probabibility parameters <var>theta1</var>,
<var>theta2</var>, ..., <var>thetan-1</var>, and the parameters of the included
distributions prefixed by <var>Mixture.i_</var> where <var>i</var> is the order
of the distribution.
</p>
<p>For example:
</p><table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">Mixture(probas=(0.3,0.7),dist1=Beta(n=5,alpha=2,beta=3),\
                       dist2=Gamma(n=10,alpha=9,beta=2)) 
</pre></div>
</td></tr></table>
<p>builds a mixture of a discrete beta distribution and of a discrete
gamma distribution, with a total of 15 classes. The parameters names
are <var>Mixture.theta1</var>, <var>Mixture.1_Beta.alpha</var>,
<var>Mixture.1_Beta.beta</var>, <var>Mixture.2_Gamma.alpha</var> and
<var>Mixture.2_Gamma.beta</var>.
</p>
</dd>
</dl>



<hr>
<span id="Estimation"></span><div class="header">
<p>
Next: <a href="#WritingSequences" accesskey="n" rel="next">WritingSequences</a>, Previous: <a href="#Distribution" accesskey="p" rel="prev">Distribution</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Numerical-parameters-estimation"></span><h3 class="section">3.7 Numerical parameters estimation</h3>

<p>Some programs allow you to (re-)estimate numerical parameters, including
</p><ul>
<li> Branch lengths

</li><li> Entries of the substitution matrices, included base frequencies values)

</li><li> Parameters of the rate distribution (currently shape parameter of the gamma law, proportion of invariant sites).

</li></ul>

<dl compact="compact">
<dt><code>optimization = {method}</code></dt>
<dd><p>where &ldquo;method&rdquo; can be one of
</p>
<dl compact="compact">
<dt><code>None</code></dt>
<dd><p>No optimization is performed, initial values are kept &ldquo;as is&rdquo;.
</p>
</dd>
<dt><code>FullD(derivatives={Newton|Gradient})</code></dt>
<dd><p>Full-derivatives method. Branch length derivatives are computed
analytically, others numerically. The <var>derivatives</var> arguments
specifies if first or second order derivatives should be used. In the
first case, the optimization method used is the so-called conjugate
gradient method, otherwise the Newton-Raphson method will be used.
</p>
</dd>
<dt><code>D-Brent(derivatives={Newton|Gradient}, nstep={int&gt;0})</code></dt>
<dd><p>Branch lengths parameters are optimized using either the conjugate
gradient or the Newton-Raphson method, other parameters are estimated
using the Brent method in one dimension. The algorithm then loops over
all parameters until convergence. The <var>nstep</var> arguments allow to
specify a number of progressive steps to perform during optimization.
If <samp>nstep=3</samp> and <samp>precision=E-6</samp>, a first optimization
with <samp>precision=E-2</samp>, will be performed, then a round with
<samp>precision</samp> set to E-4 and finally <samp>precision</samp> will be
set to E-6. This approach generally increases convergence time.
</p>
</dd>
<dt><code>D-BFGS(derivatives={Newton|Gradient}, nstep={int&gt;0})</code></dt>
<dd><p>Branch lengths parameters are optimized using either the conjugate
gradient or the Newton-Raphson method, other parameters are estimated
using the BFGS method. The algorithm then loops over all parameters
until convergence. The <var>nstep</var> arguments allow to specify a number
of progressive steps to perform during optimization. If
<samp>nstep=3</samp> and <samp>precision=E-6</samp>, a first optimization with
<samp>precision=E-2</samp>, will be performed, then a round with
<samp>precision</samp> set to E-4 and finally <samp>precision</samp> will be
set to E-6. This approach generally increases convergence time.
</p></dd>
</dl>

</dd>
<dt><code>optimization.reparametrization = {boolean}</code></dt>
<dd><p>Tells if parameters should be transformed in order to remove constraints
(for instance positivie-only parameters will be log transformed in order to obtain
 parameters defined from -inf to +inf).
This may improve the optimization, particularly for parameter-rich models,
but the likelihood calculations will take a bit more time.
</p>
</dd>
<dt><code>optimization.final = {powell|simplex}</code></dt>
<dd><p>Optional final optimization step, useful if numerical derivatives are to be used.
Leave the field empty in order to skip this step.
</p>
</dd>
<dt><code>optimization.profiler = {{path}|std|none}</code></dt>
<dd><p>A file where to dump optimization steps (a file path or std for
standard output or none for no output).
</p>
</dd>
<dt><code>optimization.message_handler = {{path}|std|none}</code></dt>
<dd><p>A file where to dump warning messages.
</p>
</dd>
<dt><code>optimization.max_number_f_eval = {int&gt;0}</code></dt>
<dd><p>The maximum number of likelihood evaluations to perform.
</p>
</dd>
<dt><code>optimization.ignore_parameter = {list&lt;chars&gt;}</code></dt>
<dd><p>A list of parameters to ignore during the estimation process. The
parameter name should include there &quot;namespace&quot;, that is their model
name, for instance K80.kappa, TN93.theta, GTR.a, Gamma.alpha, etc. For
nested models, the syntax is the following:
<code>G01.rdist_Gamma.alpha</code>, <code>TS98.model_T92.kappa</code>,
<code>RE08.lamba</code>, <code>RE08.model_G01.model_GTR.a</code>, etc.
&rsquo;Ancient&rsquo; will ignore all parameters in the ancestral frequency set
(non-homogeneous models), &rsquo;BrLen&rsquo; will ignore all branch lengths and
&rsquo;Model&rsquo; will ignore all model parameters.
</p>
<p>The &rsquo;*&rsquo; wildcard can be used, as in <code>*theta*</code> for all the
parameters whose name has <code>theta</code> in it.
</p>
</dd>
<dt><code>optimization.constrain_parameter = {list&lt;chars=interval&gt;}</code></dt>
<dd><p>A list of parameters on which the authorized values are limited to a
given interval. 
</p>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">optimization.constrain_parameter = YN98.omega = [-inf;1.9[,\
                       *theta* = [0.1;0.7[, BrLen*=[0.01;inf]
</pre></div>
</td></tr></table>

</dd>
<dt><code>optimization.tolerance = {float&gt;0}</code></dt>
<dd><p>The precision on the log-likelihood to reach.
</p>
</dd>
<dt><code>output.infos = {{path}|none}</code></dt>
<dd><p>A text file containing several statistics for each site in the
alignment.
These statistics include the posterior rate, rate class with maximum posterior probability and whether the site is conserved or not.
</p>

</dd>
</dl>

<p>The resulting tree will be written to a file specified by the general tree writing options (<a href="#WritingTrees">WritingTrees</a>).
</p>

<hr>
<span id="WritingSequences"></span><div class="header">
<p>
Next: <a href="#WritingTrees" accesskey="n" rel="next">WritingTrees</a>, Previous: <a href="#Estimation" accesskey="p" rel="prev">Estimation</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Writing-sequences_002falignments-to-files"></span><h3 class="section">3.8 Writing sequences/alignments to files</h3>

<dl compact="compact">
<dt><code>output.sequence.file = {path}</code></dt>
<dd><p>The output file where to write the sequences.
</p>
</dd>
<dt><code>output.sequence.format = {sequence format description}</code></dt>
<dd><p>The output file format, using the same syntax as for reading (see <a href="#Sequences">Sequences</a>).
Only formats Fasta, Mase and Phylip are supported for writing.
In addition, most of the formats support the <code>length</code> argument, that specifies the maximum number of sequence characters to output on each line (default set to 100).
</p>
</dd>
</dl>


<hr>
<span id="WritingTrees"></span><div class="header">
<p>
Previous: <a href="#WritingSequences" accesskey="p" rel="prev">WritingSequences</a>, Up: <a href="#Common" accesskey="u" rel="up">Common</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Writing-trees-to-files"></span><h3 class="section">3.9 Writing trees to files</h3>

<dl compact="compact">
<dt><code>output.tree.file = {path}</code></dt>
<dd><p>The phylogenetic tree file to write to.
</p>
</dd>
<dt><code>output.tree.format = {Newick|Nexus|NHX}</code></dt>
<dd><p>The format of the output tree file.
</p>
</dd>
</dl>

<p>Some programs may require that you write multiple trees to a file.
The corresponding options are then:
</p>
<dl compact="compact">
<dt><code>output.trees.file = {path}</code></dt>
<dd><p>The file that will contain multiple trees.
</p>
</dd>
<dt><code>output.trees.format = {Newick|Nexus|NHX}</code></dt>
<dd><p>The format of the output tree file.
</p>
</dd>
</dl>


<hr>
<span id="Reference"></span><div class="header">
<p>
Previous: <a href="#Common" accesskey="p" rel="prev">Common</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Bio_002b_002b-Program-Suite-Reference"></span><h2 class="chapter">4 Bio++ Program Suite Reference</h2>


<p>This section now details the specific options for each program in the Bio++ Program suite.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#bppml" accesskey="1">bppml</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Maximum Likelihood.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppseqgen" accesskey="2">bppseqgen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Sequence Generator.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppancestor" accesskey="3">bppancestor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Ancestral Sequences and Rates reconstruction.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppmixedlikelihoods" accesskey="4">bppmixedlikelihoods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Site-Likelihoods Inside Mixed Models.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppdist" accesskey="5">bppdist</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Distance Methods.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpppars" accesskey="6">bpppars</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Maximum Parsimony.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppconsense" accesskey="7">bppconsense</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Consensus Trees.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppreroot" accesskey="8">bppreroot</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Serial Tree Re-rooting.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppseqman" accesskey="9">bppseqman</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Sequences Manipulation.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bppalnscore">bppalnscore</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Alignment Scoring.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpppopstats">bpppopstats</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Population Genetics Statistics.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bpptreedraw">bpptreedraw</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Bio++ Tree Drawing.
</td></tr>
</table>

<hr>
<span id="bppml"></span><div class="header">
<p>
Next: <a href="#bppseqgen" accesskey="n" rel="next">bppseqgen</a>, Previous: <a href="#Reference" accesskey="p" rel="prev">Reference</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppML_003a-Bio_002b_002b-Maximum-Likelihood"></span><h3 class="section">4.1 BppML: Bio++ Maximum Likelihood</h3>

<p>The BppML program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>), specifying the model (see <a href="#Model">Model</a>), and estimating parameters (see <a href="#Estimation">Estimation</a>).
</p>
<p>The BppML program allows you to optimize tree topologies and model parameters and perform a bootstrap analysis.
</p>
<span id="Branch-lengths-initial-values"></span><h4 class="subsection">4.1.1 Branch lengths initial values</h4>

<dl compact="compact">
<dt><code>init.tree = {user|random}</code></dt>
<dd><p>Set the method for the initial tree to use.
The <samp>user</samp> option allows you to use an existing file using the method described in the Common options section.
This file may have been built using another method like neighbor joining or parsimony for instance.
The <samp>random</samp> option picks a random tree, which is handy to test convergence.
This may however slows down significantly the optimization process.
</p>
</dd>
<dt><code>init.brlen.method = {method description}</code></dt>
<dd><p>Set how to initialize the branch lengths.
Available methods include:
</p>
<dl compact="compact">
<dt><code>Input(midpoint_root_branch={boolean})</code></dt>
<dd><p>Keep initial branch lengths as is. Additional argument specifies if the root position should be moved to the midpoint position of the branch containing it. 
</p>
</dd>
<dt><code>Equal(value={float&gt;0})</code></dt>
<dd><p>Set all branch lengths to the same value, provided as argument.
</p>
</dd>
<dt><code>Clock</code></dt>
<dd><p>Coerce to a clock tree.
</p>
</dd>
<dt><code>Grafen(height={{real&gt;0}|input}, rho = {real&gt;0})</code></dt>
<dd><p>Uses Grafen&rsquo;s method to compute branch lengths.
In Grafen&rsquo;s method, each node is given a weight equal to the number of underlying leaves.
The length of each branch is then computed as the difference of the weights of the connected nodes, and further divided by the number of leaves in the tree.
The height of all nodes are then raised to the power of &rsquo;rho&rsquo;, a user specified value.
The tree is finally scaled to match a given total height, which can be the original one (<samp>height=input</samp>), or fixed to a certain value (usually <samp>height=1</samp>).
A value of rho=0 provides a star tree, and the greater the value of rho, the more recent the inner nodes. 
</p>
</dd>
</dl>

</dd>
<dt><code>input.tree.check_root = {boolean}</code></dt>
<dd><p>Tell if the input tree should be checked regarding to the presence of a root. If set to yes (the default), rooted trees will be unrooted if a homogenous model is used.
If not, a rooted tree will be fitted, which can lead to optimization issues in most cases. Use the non default option with care!
</p></dd>
</dl>

<span id="Topology-optimization"></span><h4 class="subsection">4.1.2 Topology optimization</h4>

<dl compact="compact">
<dt><code>optimization.topology = {boolean}</code></dt>
<dd><p>Enable the tree topology estimation.
</p>
</dd>
<dt><code>optimization.topology.algorithm = {NNI}</code></dt>
<dd><p>Algorithm to use for topology estimation: only NNI available for now.
</p>
</dd>
<dt><code>optimization.topology.algorithm_nni.method = {fast|better|phyml}</code></dt>
<dd><p>Set the NNI method to use.
<samp>fast</samp>: test sequentially all NNI, if a NNI improving the likelihood is found, it is performed.
<samp>better</samp>: test all possible NNIs, do the one with the biggest likelihood increase.
<samp>phyml</samp>: test all possible NNIs, try doing all the improving ones.
If the final likelihoods is better, perform all NNIs.
Otherwise, try to do half of them, and so on. 
In most cases the <samp>phyml</samp> option shows the best performance.
</p>
</dd>
<dt><code>optimization.topology.nstep = {int&gt;0}</code></dt>
<dd><p>Number of phyml topology movement steps before re-optimizing parameters.
</p>
</dd>
<dt><code>optimization.topology.numfirst = {boolean}</code></dt>
<dd><p>Shall we estimate parameters before looking for topology movements?
</p>
</dd>
<dt><code>optimization.topology.tolerance.before = {real&gt;0}</code></dt>
<dd><p>Tolerance for the prior-topology estimation.
The tolerance numbers should not be too low, in order to save computation time and also for a better topology estimation.
The <samp>optimization.tolerance</samp> parameter will be used for the final optimization of numerical parameters (see Common options).
</p>
</dd>
<dt><code>optimization.topology.tolerance.during = 100</code></dt>
<dd><p>Tolerance for the during-topology estimation
</p>
</dd>
<dt><code>optimization.scale_first = no</code></dt>
<dd><p>Shall we first scale the tree before optimizing parameters?
</p>
</dd>
<dt><code>optimization.scale_first.tolerance = {double}</code></dt>
<dd><p>The convergence criterion to achieve in the optimization.
</p>
</dd>
</dl>


<span id="Molecular-clock"></span><h4 class="subsection">4.1.3 Molecular clock</h4>

<p>BppML can also optimize branch lengths with a molecular clock:
</p>
<dl compact="compact">
<dt><code>optimization.clock={no|global}</code></dt>
<dd><p>Tell if a molecular clock should be assumed.
Topology estimation is not possible with a clock constraint.
</p>
</dd>
</dl>


<span id="Output-results"></span><h4 class="subsection">4.1.4 Output results</h4>

<dl compact="compact">
<dt><code>output.infos = {{path}|none}</code></dt>
<dd><p>Alignment information log file (site specific rates, etc):
</p>
</dd>
<dt><code>output.estimates = {{path}|none}</code></dt>
<dd><p>Write parameter estimated values.
</p>
</dd>
<dt><code>output.estimates.alias = {boolean}</code></dt>
<dd><p>Write the alias names of the aliased parameters instead of their
values (default: true).
</p>
</dd>
</dl>

<span id="Bootstrap-analysis"></span><h4 class="subsection">4.1.5 Bootstrap analysis</h4>

<dl compact="compact">
<dt><code>bootstrap.number = {int&gt;0}</code></dt>
<dd><p>Number of replicates. A reasonable value would be &gt;= 100.
</p>
</dd>
<dt><code>bootstrap.approximate = {boolean}</code></dt>
<dd><p>Tell if numerical parameters should be kept to their initial value when bootstrapping. 
</p>
</dd>
<dt><code>bootstrap.verbose = {boolean}</code></dt>
<dd><p>Set this to yes for detailed output when bootstrapping. 
</p>
</dd>
<dt><code>bootstrap.output.file = {{path}|none}</code></dt>
<dd><p>Where to write the resulting trees (multi-trees newick format).
</p>
</dd>
</dl>

<span id="Rather-technical-options"></span><h4 class="subsection">4.1.6 Rather technical options</h4>

<p>Theses options are mainly for debugging or testing purpose, in most case you will be happy with the default setting.
</p>
<dl compact="compact">
<dt><code>likelihood.recursion = {simple|double}</code></dt>
<dd><p>Set the type of likelihood recursion to use.
<samp>simple</samp>: derivatives take more time to compute, but likelihood computation is faster.
For big data sets, it can save a lot of memory usage too, particularly when the data are compressed.
<samp>double</samp>: uses more memory and need more time to compute likelihood, due to the double recursion.
Analytical derivatives are however faster to compute.
</p>
<p>This command has no effect in the following cases: (i) topology estimation: this requires a double recursive algorithm, (ii) optimization with a molecular clock: a simple recursion with data compression is used in this case, due to the impossibility of computing analytical derivatives.
</p></dd>
<dt><code>likelihood.recursion_simple.compression = {simple|recursive}</code></dt>
<dd>
<p>Site compression for the simple recursion:
<samp>simple</samp>: identical sites are not computed twice, <samp>recursive</samp>: look for site patterns to save computation time during optimization, but requires extra time for building the patterns.
This is usually the best option, particularly for nucleotide data sets.
</p>
</dd>
</dl>


<hr>
<span id="bppseqgen"></span><div class="header">
<p>
Next: <a href="#bppancestor" accesskey="n" rel="next">bppancestor</a>, Previous: <a href="#bppml" accesskey="p" rel="prev">bppml</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppSeqGen_003a-Bio_002b_002b-Sequence-Simulator"></span><h3 class="section">4.2 BppSeqGen: Bio++ Sequence Simulator</h3>

<p>The BppSeqGen program uses the common syntax introduced in the
previous section for setting the alphabet, loading the sequences
(see <a href="#Sequences">Sequences</a>) and tree (see <a href="#Tree">Tree</a>), specifying the model
(see <a href="#Model">Model</a>) and writing sequence data (see <a href="#WritingSequences">WritingSequences</a>).
</p>
<p>Several simulations are possible at the same time and they are base on
site substitution processes or sequence substitution processes
see <a href="#Process">Process</a>, or phylolikelihoods for posterior simulations. The
declaration is :
</p>
<dl compact="compact">
<dt><code>simul{int}={Simulation type}(process={number}, output.sequence.file={file path}, number_of_sites = {int&gt;0}[,output.sequence.format={alignement format}, output.internal.sequences = true])</code></dt>
</dl>

<p>to simulate following a process, with a given number of sites.
Optional argument <code>output.internal.sequences</code> tells if
internal sequences should be written.
</p>
<dl compact="compact">
<dt><code>simul{int}={Simulation type}(phylo={number}, pos={number}, output.sequence.file={file path}, number_of_sites ={int&gt;0}[,output.sequence.format={alignement format}])</code></dt>
</dl>

<p>to simulate following the a posteriori process in position
<code>pos</code>.
</p>
<dl compact="compact">
<dt><code>simul{int}={Simulation type}(phylo={number}, output.sequence.file={file path}[,output.sequence.format={alignement format}, number_of_sites = {int&gt;0}])</code></dt>
</dl>

<p>to simulate following the a posteriori process all along the
alignment.
</p>


<p>Up to now, simulation type does not matter. For example, if processes
number 4 and 2 have been defined before.
</p>
<div class="example">
<pre class="example">simul1=simul(process1=4, process1.positions=0:50, process2=2, process2.positions=51:200, output.sequence.file = sim1.fa)
</pre></div>

<p>Or the root sequence can be built from a file of a sequence:
</p>
<dl compact="compact">
<dt><code>input.sequence.file={path}</code></dt>
<dd><p>A sequence is be loaded, from which the simulation will be performed,
or from which a root sequence can be sampled.
(see <a href="#Sequences">Sequences</a>).
</p>
</dd>
<dt><code>input.infos = {path}</code></dt>
<dd><p>A info file like the one output by bppML.
The estimated site-specific rates will then be used to simulate the same number of sites as found in the info file, with the corresponding rates.
</p>
<p>In this case, additional options are possible:
</p>
<dl compact="compact">
<dt><code>input.infos.rates = {string}</code></dt>
<dd><p>Name of the column on which the rates are described (default: pr).
</p>
</dd>
<dt><code>input.infos.states = {string}</code></dt>
<dd><p>Name of the column on which the states are read (default: none, which
means a random sequence).
</p>
</dd>
<dt><code>input.site.selection = {string}</code></dt>
<dd><p>used to sample from the given sequence (see <a href="#Sequences">Sequences</a>).
</p>
</dd>
</dl>

<p>Addition optional arguments include:
</p>
<dl compact="compact">
<dt><code>input.tree.scale = {float}</code></dt>
<dd><p>An optional scaling factor for the branch length (default to 1.0)
</p>
</dd>
<dt><code>input.tree.method = {single|MS|CoaSim}</code></dt>
<dd><p>Format of input tree(s). By default, a single tree is expected (&rsquo;single&rsquo;). Ancestral recombination graphs (ARGs), in the form of multiple trees, can also be provided in the MS or CoaSim format.
Note that in the case of MS, ARG are given for a certain number of sites, wich should be provided as additional argument (e.g. <code>MS(number_of_sites=100)</code>).
The ARG will be unscaled according to the given size, and rescaled according to the given number of sites to simulate. ARG in CoaSim format are already in relative scale.
</p>
</dd>
</dl>

<p>In addition, command line argument <samp>--seed={int&gt;0}</samp> can be
used to set the seed of the random generator.
</p>
</dd>
</dl>

 

<hr>
<span id="bppancestor"></span><div class="header">
<p>
Next: <a href="#bppmixedlikelihoods" accesskey="n" rel="next">bppmixedlikelihoods</a>, Previous: <a href="#bppseqgen" accesskey="p" rel="prev">bppseqgen</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppAncestor_003a-Bio_002b_002b-Ancestral-Sequence-and-Rate-Reconstruction"></span><h3 class="section">4.3 BppAncestor: Bio++ Ancestral Sequence and Rate Reconstruction</h3>

<p>The BppAncestor program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>) and tree (see <a href="#Tree">Tree</a>), specifying the model (see <a href="#Model">Model</a>) and writing sequence data (see <a href="#WritingSequences">WritingSequences</a>).
</p>
<p>Specific options are:
</p><dl compact="compact">
<dt><code>output.sites.file = {{path}|none}</code></dt>
<dd><p>Alignment information log file (site specific rates, probabilities, etc).
</p>
</dd>
<dt><code>output.sites.probabilities = {boolean}</code></dt>
<dd><p>Tells if we should output the site specific probabilities in each case.
</p></dd>
<dt><code>asr.probabilities = {boolean}</code></dt>
<dd><p>Tells if we should output the site specific probabilities in each case
(on the way to deprecation).
</p>
</dd>
<dt><code>output.nodes.file = {{path}|none}</code></dt>
<dd><p>Ancestral nodes information: a posteriori probabilities of ancestral states (prefix eb).
</p>
</dd>
<dt><code>output.nodes.add_extant = {boolean}</code></dt>
<dd><p>Tell if leaf nodes should be added to the output file.
</p>


</dd>
<dt><code>asr.sequence.file = {path}</code></dt>
<dd><p>The output file where to write the sequences (has priority on
<samp>output.sequence.file</samp> option).
</p>
</dd>
<dt><code>asr.sequence.format = {sequence format description}</code></dt>
<dd><p>The output file format, using the same syntax as for reading
(see <a href="#Sequences">Sequences</a>). Only formats Fasta, Mase and Phylip are supported
for writing. In addition, most of the formats support the
<code>length</code> argument, that specifies the maximum number of
sequence characters to output on each line (default set to 100) (has
priority on <samp>output.sequence.format</samp> option).
</p>
</dd>
<dt><code>asr.sample = {boolean}</code></dt>
<dd><p>Tell if we should sample from the posterior distribution instead of using the maximum probability.
</p>
</dd>
<dt><code>asr.sample.number = 10 [[asr.sample=yes]]</code></dt>
<dd><p>Number of sample sequences to output.
</p>
</dd>
<dt><code>asr.add_extant = {boolean}</code></dt>
<dd><p>Should extant (observed) sequences be added to the output sequence
file? The sequences added are the ones which are used for the actual
calculation. It they contained gaps for instance, and that these have
been replaced by the unknown character (N or X for example), then the
sequence with unknown characters will be used.
</p>
</dd>
</dl>

<hr>
<span id="bppmixedlikelihoods"></span><div class="header">
<p>
Next: <a href="#bppdist" accesskey="n" rel="next">bppdist</a>, Previous: <a href="#bppancestor" accesskey="p" rel="prev">bppancestor</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppMixedLikelihoods_003a-Bio_002b_002b-Site_002dLikelihoods-Inside-Mixed-Models_002e"></span><h3 class="section">4.4 BppMixedLikelihoods: Bio++ Site-Likelihoods Inside Mixed Models.</h3>

<p>The BppMixedLikelihoods program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>) and tree (see <a href="#Tree">Tree</a>) and specifying the model (see <a href="#Model">Model</a>).
</p>
<p>Given a mixed parameter name of mixed model, or a mixed model made of
several models, the BppMixedLikelihoods program computes site per site
log-likelihoods of the several values of the parameter, or of the
several sub-models of the mixture. If the mixed model is built on a
parameter which value follows a distribution, and in an additional
column &ndash; named &quot;mean&quot; &ndash; the a posteriori mean value of the paramater
is computed.
</p>
<p>Specific options are:
</p><dl compact="compact">
<dt><code>output.likelihoods.file = {{path}}</code></dt>
<dd><p>Ouput file of the program (site specific log-likelihood, and mean of
the mixed parameters, if any).
</p>
</dd>
<dt><code>likelihoods.model_number = {integer}</code></dt>
<dd><p>In case of a non-homogeneous modeling, the number of the mixed model
which parameter or sub-models are considered.
</p>
</dd>
<dt><code>likelihoods.parameter_name = {string}</code></dt>
<dd><p>If the considered mixed model is built from a distribution on a
parameter, the name of the parameter to be considered. In this case,
an additional column is written, in which the average a posteriori
value of the parameter is.
</p>
</dd>
</dl>

<hr>
<span id="bppdist"></span><div class="header">
<p>
Next: <a href="#bpppars" accesskey="n" rel="next">bpppars</a>, Previous: <a href="#bppmixedlikelihoods" accesskey="p" rel="prev">bppmixedlikelihoods</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppDist_003a-Bio_002b_002b-Distance-Methods"></span><h3 class="section">4.5 BppDist: Bio++ Distance Methods</h3>
 
<p>The BppDist program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>) and tree (see <a href="#Tree">Tree</a>) and specifying the model (see <a href="#Model">Model</a>, only the section corresponding to the homogeneous case).
</p>
<p>Specific options are:
</p><dl compact="compact">
<dt><code>output.matrix.file = {{path}|none}</code></dt>
<dd><p>Where to write the matrix file (only philip format supported for now).
</p>
</dd>
<dt><code>method = {wpgma|upgma|nj|bionj}</code></dt>
<dd><p>The algorithm to use to build the tree.
</p>
</dd>
<dt><code>optimization.method = {init|pairwise|iterations}</code></dt>
<dd><p>There are several ways to optimize substitution parameters.
The <samp>init</samp> option corresponds to the standard behavior, that is, keeping them to their initial, user-provided value.
The <samp>pairwise</samp> option estimate those parameters in a pairwise manner.
This should be avoided, particularly with parameter-rich models.
Finally the <samp>iterations</samp> option corresponds to Ninio et al, Bioinformatics (2007) recursive algorithm:
After each distance tree, a global ML estimation of the substitution parameters is performed.
The estimated values are then used to rebuild a distance matrix and a tree.
The algorithm stops when the topology does not change anymore.
The ML optimization uses the parameters described in (see <a href="#Estimation">Estimation</a>).
</p>
</dd>
<dt><code>output.tree.file = {{path}|none}</code></dt>
<dd><p>The final tree, possibly with bootstrap values:
BppDist uses the same options for bootstrap analysis than the BppML program (see <a href="#bppml">bppml</a>).
</p></dd>
</dl>


<hr>
<span id="bpppars"></span><div class="header">
<p>
Next: <a href="#bppconsense" accesskey="n" rel="next">bppconsense</a>, Previous: <a href="#bppdist" accesskey="p" rel="prev">bppdist</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppPars_003a-Bio_002b_002b-Maximum-Parsimony"></span><h3 class="section">4.6 BppPars: Bio++ Maximum Parsimony</h3>
 
<p>The BppPars program is currently quite limited and should not be used for serious phylogenetic analysis.
It can compute parsimony scores and perform topology estimation using the same algorithm of BppML.
It uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>) and tree (see <a href="#Tree">Tree</a>)).
</p>
<p>Specific options are:
</p><dl compact="compact">
<dt><code>optimization.topology = {boolean}</code></dt>
<dd><p>Tell if topology has to be estimated.
</p>
</dd>
<dt><code>output.tree.file = {{path}|none}</code></dt>
<dd><p>Where to print the output file.
</p>
</dd>
<dt><code>bootstrap.number = {int&gt;0}</code></dt>
<dd><p>Number of bootstrap replicates to perform.
</p>
</dd>
<dt><code>bootstrap.output.file = {{path}|none}</code></dt>
<dd><p>Where to write bootstrap trees.
</p>
</dd>
</dl>


<hr>
<span id="bppconsense"></span><div class="header">
<p>
Next: <a href="#bppreroot" accesskey="n" rel="next">bppreroot</a>, Previous: <a href="#bpppars" accesskey="p" rel="prev">bpppars</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppConsense_003a-Bio_002b_002b-Consensus-Trees"></span><h3 class="section">4.7 BppConsense: Bio++ Consensus Trees</h3>

<p>Probably one of the simplest program to use in the suite, just takes a list of trees (for instance produced by BppML, BppDist or BppPars with the bootstrap option enabled) and compute bootstrap values for a reference tree, provided as input, or constructed using a consensus method.
The program uses the multiple-trees reading options for input (see <a href="#Tree">Tree</a>) and single-tree writing options for output.
</p>
<p>There are only specific options here:
</p><dl compact="compact">
<dt><code>tree = {tree methods}</code></dt>
<dd><p>The method to use for getting the reference tree.
Available function are:
</p>
<dl compact="compact">
<dt><code>Input</code></dt>
<dd><p>The tree is loaded using the single-tree reading options (see <a href="#Tree">Tree</a>). 
</p>
</dd>
<dt><code>Consensus(threshold = {int[0,1]})</code></dt>
<dd><p>Build a consensus tree according to a given threshold.
0 will output a fully resolved tree, 0.5 corresponds to the majority rule and 1 to the strict consensus, but any intermediate value can be specified.
</p>
</dd>
</dl>

</dd>
</dl>


<hr>
<span id="bppreroot"></span><div class="header">
<p>
Next: <a href="#bppseqman" accesskey="n" rel="next">bppseqman</a>, Previous: <a href="#bppconsense" accesskey="p" rel="prev">bppconsense</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppReroot_003a-Bio_002b_002b-Serial-Tree-Re_002drooting"></span><h3 class="section">4.8 BppReroot: Bio++ Serial Tree Re-rooting</h3>
 
<dl compact="compact">
<dt><code>input.trees.file={path}</code></dt>
<dd><p>A path toward multi-trees file (newick).
</p>
</dd>
<dt><code>outgroups.file={path}</code></dt>
<dd><p>A path toward a file containing the different levels of outgroups.
</p>
</dd>
<dt><code>print.option={boolean}</code></dt>
<dd><p>If set to true, the unrootable trees are printed as unrooted in the output file, otherwise the unrootable trees are not printed.
</p>  
</dd>
<dt><code>tryAgain.option={boolean}</code></dt>
<dd><p>If set to true and ReRoot finds a non-monophyletic outgroup, it tries the next outgroup.
Otherwise, if ReRoot finds a non-monophyletic outgroup, the analysis for this tree is interrupted.
No more outgroup are analysed.
</p>
</dd>
<dt><code>output.trees.file={path}</code></dt>
<dd><p>File where to write the rerooted trees.
</p>
</dd>
</dl>


<hr>
<span id="bppseqman"></span><div class="header">
<p>
Next: <a href="#bppalnscore" accesskey="n" rel="next">bppalnscore</a>, Previous: <a href="#bppreroot" accesskey="p" rel="prev">bppreroot</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppSeqMan_003a-Bio_002b_002b-Sequence-Manipulation"></span><h3 class="section">4.9 BppSeqMan: Bio++ Sequence Manipulation</h3>

<p>The Bio++ Sequence Manipulator convert between various file formats, and can also perform various operations on sequences.
It uses the common options for setting the alphabet, loading the sequences (see <a href="#Sequences">Sequences</a>) and writing the resulting data set (see <a href="#WritingSequences">WritingSequences</a>).
It can use the &ldquo;Generic&rdquo; option for alphabets if only file format conversion is to be performed, but the correct alphabet must be specified for more advanced manipulations, like in silico molecular biology.
</p>
<p>BppSeqMan can perform any number of elementary operation, in any order, providing the output of operation n is compatible with input of operation n+1, and that the input of operation 1 is compatible with the input data.
</p>
<p>Specific options:
</p><dl compact="compact">
<dt><code>input.alignment = {boolean}</code></dt>
<dd><p>Are the input sequence aligned? If so site selection and filtering is enabled and can be used to preprocess the input data.
</p>
</dd>
<dt><code>sequence.manip = {list&lt;string&gt;}</code></dt>
<dd><p>The list, in appropriate order, of elementary operations to perform.
See below for a list of these operations.
</p></dd>
</dl>

<dl compact="compact">
<dt><samp>Complement [[alphabet = DNA or RNA]]</samp></dt>
<dd><p>Convert to the complementary sequence, keeping the original alphabet.
</p>
</dd>
<dt><samp>Transcript [[alphabet = DNA or RNA]]</samp></dt>
<dd><p>Convert to the complementary sequence, switching the type of alphabet (DNA&lt;-&gt;RNA).
</p>
</dd>
<dt><samp>Switch [[alphabet = DNA or RNA]]</samp></dt>
<dd><p>Change the alphabet type (DNA&lt;-&gt;RNA).
</p>
</dd>
<dt><samp>Translate [[alphabet = DNA or RNA]]</samp></dt>
<dd><p>Convert to proteins.
The genetic code used for translation is set via the genetic_code option.
Genetic code is set once for all sequences.
</p>
</dd>
<dt><samp>Invert</samp></dt>
<dd><p>Invert the sequence 5&rsquo; &lt;-&gt; 3&rsquo; or N &lt;-&gt; C
</p>
</dd>
<dt><samp>RemoveGaps</samp></dt>
<dd><p>Remove all gaps in sequences (ie, &rsquo;unalign&rsquo;).
</p>
</dd>
<dt><samp>GapToUnknown</samp></dt>
<dd><p>Change gaps to fully unresolved characters, N for nucleotides and X for proteins.
</p>
</dd>
<dt><samp>UnknownToGap</samp></dt>
<dd><p>Change (partially) unresolved characters to gaps.
</p>
</dd>
<dt><samp>RemoveStops</samp></dt>
<dd><p>Remove all stop codons in sequences. If sequences are aligned, stop codons will be replaced by gaps.
The genetic code used for translation is set via the genetic_code option.
Genetic code is set once for all sequences.
</p>
</dd>
<dt><samp>RemoveEmptySequences</samp></dt>
<dd><p>Remove all empty sequences (ie sequences with only gaps).
</p>
</dd>
<dt><samp>RemoveColumnsWithStop</samp></dt>
<dd><p>Remove all sites with at least one stop codon.
The genetic code used for translation is set via the genetic_code option.
Genetic code is set once for all sequences.
</p>
</dd>
<dt><samp>GetCDS</samp></dt>
<dd><p>Remove the first stop codon and everything after in codon sequences.
</p>
</dd>
<dt><samp>CoerceToAlignment</samp></dt>
<dd><p>Try to convert a set of sequence to an alignment. This will fail if sequences do not have the same length.
This step is required before trying commands &rsquo;ResolveDotted&rsquo; or &rsquo;KeepComplete&rsquo;.
</p>
</dd>
<dt><samp>ResolveDotted(alphabet={RNA|DNA|Proteins}) [[Aligned sequences]]</samp></dt>
<dd><p>Convert a human-readable alignment to a machine-readable alignment.
This manipulation must be first if it is used, and the data must be load with the <samp>Generic</samp> alphabet.
<samp>alphabet</samp>: The alphabet to use in order to resolve a dotted alignment.
</p>
</dd>
<dt><samp>KeepComplete(maxGapAllowed={int&gt;0} or {float[0,100]}+%) [[Aligned sequences]]</samp></dt>
<dd><p>Keep only complete sites, ie sites without any gap. Sites with unresolved characters are not removed.
It is also possible to fix a maximum proportion of gaps, see specific options.
<samp>maxGapAllowed</samp>: The maximum proportion of gaps allowed.
</p>
</dd>
<dt><samp>GetCodonPosition(position={1|2|3})</samp></dt>
<dd><p>Retrieve the given positions from codon sequences (aligned or not).
</p>
</dd>
<dt><samp>FilterFromTree(tree.file={path}, tree.format={chars})</samp></dt>
<dd><p>Get a subset of sequences based on a tree file. The order of sequences in the file will reflect the tree structure. All sequences which do not have a corresponding leaf in the tree, based on the sequence name, will be removed.
This method can therefore be used for subsetting a list of sequences, and/or rearrange them in a more convenient manner.
</p>
</dd>
</dl>

<p>Examples of use:
</p>
<ul>
<li> Just change file format:
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">sequence.manip=
input.sequence.sites_to_use = all
</pre></div>
</td></tr></table>

</li><li> Change DNA to RNA:
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">sequence.manip=Switch
input.sequence.sites_to_use = all
</pre></div>
</td></tr></table>

</li><li> Unalign sequences, perform transcription and translate to proteins:
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">sequence.manip=RemoveGaps,Transcript,Translate
input.sequence.sites_to_use = all
</pre></div>
</td></tr></table>

</li><li> Change all unresolved characters to gaps and keep only positions with less than 5 gaps:
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">sequence.manip=UnknownToGap,KeepComplete(maxGapAllowed=5)
input.sequence.sites_to_use = all
</pre></div>
</td></tr></table>

</li><li> Keep only positions with less than 30% of gaps, and change them to unresolved characters:
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example">sequence.manip=KeepComplete(maxGapAllowed=30%),GapToUnknown
input.sequence.sites_to_use = all
</pre></div>
</td></tr></table>

</li></ul>


<hr>
<span id="bppalnscore"></span><div class="header">
<p>
Next: <a href="#bpppopstats" accesskey="n" rel="next">bpppopstats</a>, Previous: <a href="#bppseqman" accesskey="p" rel="prev">bppseqman</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppAlnScore_003a-Bio_002b_002b-Alignment-Scoring"></span><h3 class="section">4.10 BppAlnScore: Bio++ Alignment Scoring</h3>

<p>This program compares two alignments and computes column scores.
Scores are output to a text file, and/or can be used to generate
a site selection, to be output in a mase file.
</p>
<p>The two input alignments are specified using the input.sequences
procedures (see <a href="#Sequences">Sequences</a>), with suffixes &ldquo;.test&rdquo; for the
first one, and &ldquo;.ref&rdquo; for the second. Scores will be computed 
for each column of the &ldquo;.test&rdquo; alignment.
</p>
<p>Two scores are computed, following work by Thompson (1999):
</p><dl compact="compact">
<dt><em>column score (CS)</em></dt>
<dd><p>is 1 if the column is found in the reference alignment, 0 otherwise.
</p></dd>
<dt><em>sum-of-pairs score (SPS)</em></dt>
<dd><p>is the proportion of pairs of residues which are also aligned in
the reference alignment.
</p></dd>
</dl>

<p>Specific options:
</p><dl compact="compact">
<dt><code>output.scores = {path}</code></dt>
<dd><p>A text file where scores can be written, one row per column.
If set to &rsquo;none&rsquo;, no file will be produced.
</p>
</dd>
<dt><code>output.mase = {path}</code></dt>
<dd><p>If not &rsquo;none&rsquo;, a Mase alignment will be generated, as a copy
of the &ldquo;.test&rdquo; input alignment, with two sites selections
names CS and SPS.
</p>
</dd>
<dt><code>output.sps_thresholds = {float}</code></dt>
<dd><p>The threshold to use for generating the site selection based 
on SPS score. All positions with at least the threshold value
will be included in the selection.
</p>
</dd>
<dt><code>score.word_size = {int&gt;0}</code></dt>
<dd><p>If alignment is for a word alphabet (typically codons), the word
size can be specified in order to produce a compatible site selection.
Please note that in this case, the alignment must not be loaded with
the world alphabet, but the corresponding letter alphabet.
</p>
</dd>
<dt><code>score.phase = {int&gt;0|chars}</code></dt>
<dd><p>Eather a number (1-based) stating the starting position for words,
or the starting word. In this latter case, the first occurrence of the
word in all sequences will be used to determine the phase.
</p>
</dd>
</dl>



<hr>
<span id="bpppopstats"></span><div class="header">
<p>
Next: <a href="#bpptreedraw" accesskey="n" rel="next">bpptreedraw</a>, Previous: <a href="#bppalnscore" accesskey="p" rel="prev">bppalnscore</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppPopStats_003a-Bio_002b_002b-Population-Genetics-Statistics"></span><h3 class="section">4.11 BppPopStats: Bio++ Population Genetics Statistics</h3>

<p>The <code>BppPopStats</code> program computes population genetics statistics from a sequence input alignement.
It can compute glabal alignment statistics, as well as site-specific statistics. In the first case, results
are output on screen or in a log file. In the second case, results are written in a table file, with one site per line.
Statistics available also depend on the type on input data (coding or non-coding).
</p>
<p><code>BppPopStats</code> recognizes the standard options for alphabet and genetic code, in case a codon alphabet was specified.
Sequences will be considered as coding if encoded with a codon alphabet, and non-coding otherwise.
</p>
<span id="Specific-options"></span><h4 class="subsection">4.11.1 Specific options</h4>

<dl compact="compact">
<dt><code>input.sequence.file.ingroup = {path}</code></dt>
<dd><p>Path toward the file containing the ingroup sequences.
</p>
</dd>
<dt><code>input.sequence.format.ingroup = {string}</code></dt>
<dd><p>Alignment input format, following standard options.
</p>
</dd>
<dt><code>input.sequence.file.outgroup = {path}</code></dt>
<dd><p>Path toward the file containing the outgroup sequences.
</p>
</dd>
<dt><code>input.sequence.format.outgroup = {string}</code></dt>
<dd><p>Alignment input format, following standard options.
</p>
</dd>
<dt><code>input.sequence.file = {path}</code></dt>
<dd><p>Path toward the file containing all sequences.
This option is only recognized if <code>input.sequence.file.ingroup</code> was not specified.
</p>
</dd>
<dt><code>input.sequence.format = {string}</code></dt>
<dd><p>Alignment input format, following standard options.
</p>
</dd>
<dt><code>input.sequence.outgroup.index = {[int&gt;0]}</code></dt>
<dd><p>Vector of positions indicating the positions of the outgroup sequences in the alignment.
This option is only recognized if <code>input.sequence.file.ingroup</code> was not specified.
</p>
</dd>
<dt><code>input.sequence.outgroup.name = {[string]}</code></dt>
<dd><p>Vector of sequence names indicating the positions of the outgroup sequences in the alignment.
This option is only recognized if <code>input.sequence.file.ingroup</code> was not specified.
</p>
</dd>
<dt><code>input.sequence.stop_codons_policy = Keep|RemoveIfLast|RemoveAll</code></dt>
<dd><p>Tells what to do with positions containing at least one stop codon: keep them, remove them only if they are at the end of the alignment, or remove them all.
</p>
</dd>
<dt><code>estimate.kappa = {[boolean]}</code></dt>
<dd><p>Tells if the ratio of transitions / transversion should be estimated from the data and used for further analyses. If yes, kappa will be estimated by maximum likelihood using a model of (codon) sequence evolution.
</p>
</dd>
<dt><code>estimate.ancestor = {[boolean]}</code></dt>
<dd><p>If an outgroup sequence is present, it will be used to estimate the ancestral allele for each polymorphic position.
A model of (codon) sequence evolution will be used with a marginal ancestral state reconstruction method.
</p>
</dd>
<dt><code>estimate.sample_ingroup = {[bollean]}</code></dt>
<dd><p>Tell if a random subset of ingroup sequences should be used to fit model (speeds up calculations in case of large data sets).
</p>
</dd>
<dt><code>estimate.sample_ingroup.size = {[integer]}</code></dt>
<dd><p>Number of ingroup sequences to sample.
</p>
</dd>
<dt><code>pop.stats = {[string]}</code></dt>
<dd><p>The list of statistics to compute. The next section describes all available statistics.
</p>
</dd>
<dt><code>logfile = {path}</code></dt>
<dd><p>Optional file where to output results.
</p>
</dd>
</dl>

<span id="Available-statistics"></span><h4 class="subsection">4.11.2 Available statistics</h4>

<dl compact="compact">
<dt><code>SiteFrequencies</code></dt>
<dd><p>Output the number of segregating sites as well as the number of singletons.
</p> 
</dd>
<dt><code>Watterson75</code></dt>
<dd><p>Compute Watterson&rsquo;s nucleotide diversity estimator (theta, averaged per site).
</p>
</dd>
<dt><code>Tajima83</code></dt>
<dd><p>Compute Tajima&rsquo;s nucleotide diversity estimator (pi, averaged per site).
</p>
</dd>
<dt><code>TajimaD</code></dt>
<dd><p>Compute Tajima&rsquo;s D. If a codon alignment is specified (and alphabet is set to codon type),
the <code>positions</code> argument further allow to compute Tajima&rsquo;s D on synonymous sites only
(<code>positions=synonymous</code>), non-synonymous sites (<code>positions=non-synonymous</code>).
Default is to use all sites (<code>positions=all</code>).
</p>
</dd>
<dt><code>FuAndLiDStar | FuAndLiFStar</code></dt>
<dd><p>Compute Fu and Li&rsquo;s (1993) D and F statistics. If argument <code>tot_mut</code> is set to yes,
then the total number of mutations is used in the calculation, instead of the number of segregating sites (default).
</p>
</dd>
<dt><code>PiN_PiS</code></dt>
<dd><p>For codon sequences only, obviously. Compute nucleotide diversity at synonymous and non-synonymous site,
the number of synonymous and non-synonymous sites, as well as the weighted ratio (PiN / NbN) / (PiS / NbS). 
</p>
</dd>
<dt><code>dN_dS</code></dt>
<dd><p>For codon sequences only. Build the consensus sequence of both ingroup and outgroup alignments and fit a Yang and Nielsen model of codon sequence evolution with a maximum likelihood approach.
Reports the estimated parameters omega (dN / dS ratio) and kappa (transitions / transversions ratio), as well as the divergence between the two sequences. 
</p>
</dd>
<dt><code>MKT</code></dt>
<dd><p>Compute the MacDonald-Kreitman table, for codon sequences with outgroup.
</p>
</dd>
<dt><code>CodonSitesStatistics</code></dt>
<dd><p>Generate a table with codon-site specifics statistics, including:
</p>
<ul>
<li> Whether the site is complete or not

</li><li> Number of distinct states

</li><li> Minor allele frequency

</li><li> Major allele frequency

</li><li> Minor allele

</li><li> Major allele

</li><li> State in the first outgroup sequence, if any

</li><li> Ancestral state, if computed

</li><li> Mean number of synonymous positions for polymorphism

</li><li> Whether the site is synonymous polymorphic

</li><li> Whether the site is four-fold degenerated

</li><li> Non-synonymous diversity (piN)

</li><li> Synonymous diversity (piS)

</li><li> Mean number of synonymous positions for divergence

</li><li> dN, if an outgroup is available

</li><li> dS, if an outgroup is available

</li></ul>

<p>The <code>output.file</code> argument allows to specify the output file (mandatory).
</p>
</dd>
</dl>


<hr>
<span id="bpptreedraw"></span><div class="header">
<p>
Previous: <a href="#bpppopstats" accesskey="p" rel="prev">bpppopstats</a>, Up: <a href="#Reference" accesskey="u" rel="up">Reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="BppTreeDraw_003a-Bio_002b_002b-Tree-Drawing"></span><h3 class="section">4.12 BppTreeDraw: Bio++ Tree Drawing</h3>

<p>This is a simple program that outputs a tree in various vector formats.
It takes as input a tree following the standard syntax.
</p>
<p>Specific options:
</p><dl compact="compact">
<dt><code>output.drawing.file = {path}</code></dt>
<dd><p>The file where to output the figure.
</p>
</dd>
<dt><code>output.drawing.format = {Svg|Xfig|Inkscape|Pgf}</code></dt>
<dd><p>The file format.
</p></dd>
<dt><code>output.drawing.plot = {plotting algorithm}</code></dt>
<dd><p>The plotting algorithm can be either Phylogram or Cladogram.
They follow the keyval syntax, with the following arguments:
</p></dd>
</dl>

<dl compact="compact">
<dt><samp>xu, yu {float}</samp></dt>
<dd><p>The scale units for x and y axis.
</p>
</dd>
<dt><samp>direction.h {left2right|right2left}</samp></dt>
<dd><p>Horizontal orientation of the tree plot.
</p>
</dd>
<dt><samp>direction.v {top2bottom|bottom2top}</samp></dt>
<dd><p>Vertical orientation of the tree plot.
</p>
</dd>
<dt><samp>draw.leaves, draw.ids, draw.brlen, draw.bs {boolean}</samp></dt>
<dd><p>Tell if leaf names, node ids, branch lengths and/or bootstrap should be drawn.
</p>
</dd>
</dl>




<hr>



</body>
</html>
