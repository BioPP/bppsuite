\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename bppsuite.info
@settitle BppSuite Manual 0.6.0
@documentencoding UTF-8
@afourpaper
@dircategory Science Biology Genetics
@direntry
* bppml: (bppml)                Bio++ Maximum Likelihood.
* bppseqgen: (bppseqgen)        Bio++ Sequence Generator.
* bppancestor: (bppancestor)    Bio++ Ancestral Sequences and Rates reconstruction.
* bppdist: (bppdist)            Bio++ Distance Methods.
* bpppars: (bpppars)            Bio++ Maximum Parsimony.
* bppconsense: (bppconsense)    Bio++ Consensus Trees.
* bppphysamp: (bppphysamp)      Bio++ Phylogenetic Sampler.
* bppreroot: (bppreroot)        Bio++ Serial Tree Re-rooting.
* bppseqman: (bppseqman)        Bio++ Sequences Manipulation.
* bpptreedraw: (bpptreedraw)    Bio++ Tree Drawing.
@end direntry
@c %**end of header

@include version.texi

@copying
This is the manual of the Bio++ Program Suite, version @value{VERSION}, @value{UPDATED}.

Copyright @copyright{} 2007, 2008, 2009, 2010, 2011 Bio++ development team
@end copying

@titlepage
@title BppSuite Manual
@author Julien Dutheil, Laurent GuÃ©guen
@author @email{julien.dutheil@@univ-montp2.fr}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1fill1
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top The Bio++ Program Suite Manual

@insertcopying
@end ifnottex

@menu
* Introduction::                Introducing the Bio++ Program Suite and this manual.                
* Syntax::                      A general description of the syntax used to communicate with the programs.
* Common::                      Common options shared by several programs.                      
* Reference::                   The exhaustive list of options available for all programs in the Bio++ Program Suite.

@detailmenu
 --- The Detailed Node Listing ---

Common options encountered in several programs.

* Sequences::                   Loading sequences/alignments.
* Tree::                        Loading trees.
* Model::                       Setting up a substitution model.
* Estimation::                  Estimating parameters by maximizing a likelihood function.
* WritingSequences::            Writing sequences/alignments to files. 

Bio++ Program Suite Reference

* bppml::                       Bio++ Maximum Likelihood.
* bppseqgen::                   Bio++ Sequence Generator.
* bppancestor::                 Bio++ Ancestral Sequences and Rates reconstruction.
* bppdist::                     Bio++ Distance Methods.
* bpppars::                     Bio++ Maximum Parsimony.
* bppconsense::                 Bio++ Consensus Trees.
* bppphysamp::                  Bio++ Phylogenetic Sampler.
* bppreroot::                   Bio++ Serial Tree Re-rooting.
* bppseqman::                   Bio++ Sequences Manipulation.
* bpptreedraw::                 Bio++ Tree Drawing.

@end detailmenu
@end menu

@c ------------------------------------------------------------------------------------------------------------------

@node Introduction, Syntax, Top, Top
@chapter Introduction

The Bio++ Program Suite is a package of programs using the Bio++ libraries and dedicated to Phylogenetics and Molecular Evolution.
All programs are independent, but can be combined to perform rather complex analyses.
These programs use the interface helper tools of the libraries, and hence share the same syntax.
They also have several options in common, which may also be shared by third-party software.
This manual was hence split into three parts: 
@table @emph
@item Bio++ option file syntax
A general description of the language used to interact with the programs.

@item Shared options
A more detailed description about several options that are encountered in several programs.
This includes input/output of data and model specifications.

@item The Bio++ Program Suite reference
Include a reference of all available options for each program in the package.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Syntax, Common, Introduction, Top
@chapter Syntax description

@section Calling the programs and writing the option files.

The programs in the Bio++ Program Suite are command line-driven.
Arguments may be passed as @command{parameter=value} options, either directly to the command line or
using an option file:
@cartouche
@example
@{program@} parameter1=value1 parameter2=value2 ... parameterN=valueN
@end example
@end cartouche
or
@cartouche
@example
@{program@} param=option_file
@end example
@end cartouche
where @{program@} is the name of the program to use (bppml, bppseqgen, etc.).
Option files contain @command{parameter=value} lines, with only one parameter per line.
They can be written from scratch using a regular text editor, but since these files can potentially turn to be quite complex, it is probably wiser to start with a sample provided along with the program (if any!).

Extra-space may be included between parameter names, equal sign and value:
@cartouche
@example
first_parameter   = value1
second_parameter  = value2
@end example
@end cartouche
and lines can be broken using the backslash character:
@cartouche
@example
parameter = value1,\
            value2,\
            value3
@end example
@end cartouche

Comment may be included, in either scripting format:
@cartouche
@example
# This is a comment
@end example
@end cartouche
C format:
@cartouche
@example
/* This is a comment
*/
@end example
@end cartouche
or C++ format:
@cartouche
@example
// This is a comment
@end example
@end cartouche
Command line and file options may be combined:
@cartouche
@example
@{program@} param=option_file parameterX=valueX
@end example
@end cartouche
In case @command{parameterX} is specified in both option file and command line, the command line value will be used.
This allows to run the programs several times by changing a single option, like the name of the data set for instance.

Option files can be nested, by using @command{param=nestedoptionfile} within an option file, as with the command line.
It is possible to use this option as often as needed, this will load all the required option files.

@section Different types of options

The next chapters describe the whole set of options available in BppSuite.
For each parameter, the type of parameter value expected is defined as:
@table @command
@item @{chars@}
A character chain

@item @{path@}
A file path, which may be absolute or related to the current directory

@item @{int@}
An integer

@item @{int@}, @{int>0@}, @{int>=0@}, @{int[2,10]@}
An integer, a positive integer, a positive non-null integer, an
integer falling between 2 and 10

@item @{real@}, @{real>0@}, etc
A real number, a positive real number, etc.

@item @{boolean@}
A Boolean value, which may be one of 'yes', 'no', 'true' or 'false'

@item @{xxx|yyy|zzz@}
A set of allowed values

@item @{list<type>@}
A list of values of specified type, separated by comas.

@end table

If an option availability or choice depends on another parameters, it will be noted as

@example
parameter1=@{xxx|yyy|zzz@}

parameter2=@{chars@} [[parameter1=zzz]]
@end example
meaning that parameter2 is available only if parameter1 is set to 'zzz'.

Any optional argument will be noted within hooks [].

In some cases, the argument value is more complexe and follows the 'keyval'
syntax.
This syntax will be quite familiar for users using languages like R, Python, or
certain LaTeX packages.
A keyval procedure is a name that does no contain any space, together with some
arguments within parentheses.
The arguments take the form @command{key=value}, separated by comas:
@cartouche
@example
parameter=Function(name1=value1, name2=value2)
@end example
@end cartouche
Space characters are allowed around the '=' and ',' ponctuations.

@section Variables

It is possible to recall anywhere the value of an option by using $(parameter).
@cartouche
@example
optimization.topology.algorithm = NNI
optimization.topology.algorithm_nni.method = phyml
output.tree = MyData_$(optimization.topology.algorithm)_$(optimization.topology.algorithm_nni.method).dnd
@end example
@end cartouche
You can use this syntax to define global variables:
@cartouche
@example
data=MyData
sequence.file=$(data).fasta
input.tree=$(data).dnd
output.infos=$(data).infos
@end example
@end cartouche

Important note: it is not possible to use a macro with the 'param' option.
This is because all nested option files are parsed before the variable resolution.
Writing @command{param=$(model1).bpp} will not work, but this allows the user to override variables in nested files, as with the command line.
For instance:
@cartouche
@example
#Option file 1:
param=options2.bpp
sequence.file=$(data).fasta
sequence.format=Fasta
@end example
@end cartouche
@cartouche
@example
#Option file 2:
data=LSU
#etc
@end example
@end cartouche
 
@c ------------------------------------------------------------------------------------------------------------------

@node Common, Reference, Syntax, Top
@chapter Common options encountered in several programs.

@c ------------------------------------------------------------------------------------------------------------------

@menu
* Sequences::                   Loading sequences/alignments.
* Tree::                        Loading trees.
* Model::                       Setting up a substitution model.
* Estimation::                  Estimating parameters by maximizing a likelihood function.
* WritingSequences::            Writing sequences/alignments to files. 
@end menu

@node Sequences, Tree, Common, Common
@section Setting alphabet and reading sequences

@table @command
@item alphabet =
@{DNA|RNA|Protein|Word(letter=@{DNA|RNA|Protein@},length=@{int@})|
Codon(letter=@{DNA|RNA@}, type=@{Standard|EchinodermMitochondrial|InvertebrateMitochondrial|\
VertebrateMitochondrial@})@}
The alphabet to use when reading sequences. 

@item input.sequence.file=@{path@}
The sequence file to use. Depending on the program, these sequences have or do not have to be aligned.

@item input.sequence.format = @{sequence format description@}
The sequence file format.

@end table
Since Bio++ Program Suite version 0.4.0, the format description uses the keyval syntax.
The format is a function, with optional parameters:

@table @command

@item Fasta()
The fasta format.

@item Mase(siteSelection=@{chars@})
The Mase format (as read by Seaview and Phylo_win for instance), with an optional site selection name.

@item Phylip(order=@{interleaved|sequential@}, type=@{classic|extended@}, split=@{spaces|tab@})
The Phylip format, with several variations.
The argument @command{order} distinguishes between sequential and interleaved format, while the option @command{type} distinguished between the plain old Phylip format and the more recent extension allowing for sequence names longer than 10 characters, as understood by PAML and PhyML.
Finally, the @command{split} argument specifies the type of character that separates the sequence name from the sequence content.
The conventional option is to use one (classic) or more (extended) spaces, but tabs can also be used instead.

@item Clustal(extraSpaces=@{int@})
The Clustal format.
In its basic set up, sequence names do not have space characters, and one space splits the sequence content from its name.
The parser can however be configured to allow for spaces in the sequence names, providing a minimum number of space characters is used to split the content from the name.
Setting @command{extraSpaces} to 5 for instance, the sequences are expected to be at least 6 spaces away for their names.

@item Dcse()
The DCSE alignment format. The secondary structure annotation will be ignored.

@item Nexus()
The Nexus alignment format.
Only very basic support is provided.

@end table

For programs that do not require the sequences to be aligned, the following formats are also available:
@table @command

@item GenBank()
Very basic support: only retrieves the sequence content for now, all features are ignored.

@end table

Basic operations can be performed on the sequences:

@table @command

@item input.sequence.sites_to_use = @{all|nogap|complete@}
This option only works if the program requires an alignment.
Tells which sites to use.
The @option{nogap} option removes all sites containing at least one
gap, and the @option{complete} option removes all sites containing at
least one gap or one generic character, as 'X' for instance.

@item input.sequence.remove_stop_codons = @{boolean@}
This option only works if the alphabet is a codon alphabet. Removes
the sites where there is a stop codon (default: 'yes').

@item input.sequence.max_gap_allowed=100%
This option only works if the program requires an alignment.
Only works when the @option{all} option is selected.
It specifies the maximum amount of gap allowed per site, as a number
of sequence or a percentage.
Sites not matching the criterion will not be included in the analysis, but the
original site numbering will be used in the output files (if relevant).

@end table
 
@c ------------------------------------------------------------------------------------------------------------------

@node Tree, Model, Sequences, Common
@section Reading trees

@table @command
@item input.tree.file = @{path@}
The phylogenetic tree file to use.

@item input.tree.format = @{Newick|Nexus@}
The format of the input tree file.

@end table

Some programs may require that your file contains several trees.
The corresponding options are then:

@table @command
@item input.trees.file = @{path@}
The file containing multiple trees.

@item input.trees.format = @{Newick|Nexus@}
The format of the input tree file.

@end table


@c ------------------------------------------------------------------------------------------------------------------

@node Model, Estimation, Tree, Common
@section Model specification

The substitution model specification over the tree is set up in different parts.
@table @command
@item nonhomogeneous = @{no|one_per_branch|general@}
Set the type of model. The @option{no} option is used for homogeneous
models. The @option{one_per_branch} option is used as a short cut for
setting branch models (for instance Galtier and Gouy 97 for branch GC content, or PAML branch model), and the
@option{general} option for the more general case, including PAML clade models.
In either of the last two cases, the model is potentially non-stationary, that is, possibly not at the equilibrium and hence
includes the root frequencies as additional parameters. If the
substitution model is not the same across the tree, then the model is
also non-homogeneous.
@end table

In combination with those models, one can also specify a distribution of site-specific rate.

@subsection Setting up the substitution model

@table @command

@item model = @{model description@}
A description of the substitution model to use, using the keyval syntax.

@end table
From version 0.4.0 of BppSuite, the model specification uses a
completely new syntax, based on the keyval (key = value) scheme. The
old option files will hence not be compatible with new version of the
software. The new syntax however is hopefully more intuitive, and more
generalizable, so that few changes are expected when new models will
be built. The substitution model is a function, potentially including
parameters. The following table lists the set of usable functions, and
their parameters.

@subsubsection Nucleotide models

@table @command

@item JC69
The Jukes and Cantor model. This model has no additional parameter.

@item K80(kappa=@{real>0@})
The Kimura 2 parameters model. @var{kappa} is the transition over transversion ratio.

@item F84(kappa=@{real>0@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Felsenstein's 1984 substitution model, with
transition/transversion ratio and 4 distinct equilibrium frequencies,
set using three independent parameters: @var{theta} is the GC content,
@var{theta1} is the proportion of G / (G + C) and @var{theta2} is the
proportion of A / (A + T or U). The @var{useObservedFreqs} option set
the @var{theta}s parameters according to the observed counts in the
data set, and @var{useObservedFreqs.pseudoCount} is a quantity,
defaulting to 0, that can be used in case some counts are zero, on
small data sets for instance. The corrected values are computed as:
@tex
$$\pi_i = {f_i + \psi \over 4\cdot\psi + \sum_j f_j}$$
@end tex

@item HKY85(kappa=@{real>0@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Hasegawa, Kishino and Yano 1985's substitution model.
The model is similar to @command{F84}, but with a different implementation.
The @var{kappa} parameter used here is comparable to the one in @command{K80}.

@item T92(kappa=@{real>0@}, theta=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Tamura 1992's model for nucleotides, similar to @command{HKY85}, yet assuming that the frequencies of A = T/U and G = C.

@item TN93(kappa1=@{real>0@}, kappa2=@{real>0@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Tamura and Nei 1993's model, similar to @command{HKY85}, but allowing for two distinct transition/transversion ratios.

@item GTR(a=@{real>0@}, b=@{real>0@}, c=@{real>0@}, d=@{real>0@}, e=@{real>0@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
The General Time-Reversible substitution model.
Parameters @var{a}, @var{b}, @var{c}, @var{d}, @var{e} are the entries of the exchangeability matrix.

@item L95(beta=@{real>0@}, gamma=@{real>0@}, delta=@{real>0@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
The strand-symmetric model of Lobry 1995, for nucleotides.

@end table

@subsubsection Protein models

@table @command

@item JC69
The Jukes and Cantor model. This model has no additional parameter.

@item DSO78
Protein substitution model, using the dcmutt implementation of Kosiol and Goldman 2005.

@item JTT92
Protein substitution model, using the dcmutt implementation of Kosiol and Goldman 2005.

@item WAG01
Protein substitution model, from Whelan & Goldman 2001.

@item LG08
Protein substitution model, from Le & Gascuel 2008.

@item LLG08_EX2(relrate1=@{real]0,1[@}, relproba1=@{real]0,1[@})
Protein substitution model, from Le, Lartillot & Gascuel 2008. See
the meaning of the variables in the Mixture model below.

@item LLG08_EX3(relrate1=@{real]0,1[@}, relrate2=@{real]0,1[@}, relproba1=@{real]0,1[@}, relproba2=@{real]0,1[@})
Protein substitution model, from Le, Lartillot & Gascuel 2008.  See
the meaning of the variables in the Mixture model below.

@item LLG08_EHO(relrate1=@{real]0,1[@}, relrate2=@{real]0,1[@}, relproba1=@{real]0,1[@}, relproba2=@{real]0,1[@})
Protein substitution model, from Le, Lartillot & Gascuel 2008. See
the meaning of the variables in the Mixture model below.

@item LLG08_UL2(relrate1=@{real]0,1[@}, relproba1=@{real]0,1[@})
Protein substitution model, from Le, Lartillot & Gascuel 2008. See
the meaning of the variables in the Mixture model below.

@item LLG08_UL3(relrate1=@{real]0,1[@}, relrate2=@{real]0,1[@}, relproba1=@{real]0,1[@}, relproba2=@{real]0,1[@})
Protein substitution model, from Le, Lartillot & Gascuel 2008. See
the meaning of the variables in the Mixture model below.

@item DSO78+F(theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005 and free equilibrium frequencies. The @var{thetaX}
are frequencies parameters, where X is 1 to 19. Parameter @var{theta1}
is the proportion of A, @var{theta2} is the proportion of R over
(1-A), @var{theta3} the proportion of N over (1-A-R), etc.

@item JTT92+F(theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Protein substitution model, using the dcmutt implementation of Kosiol
and Goldman 2005 and free equilibrium frequencies.

@item WAG01+F(theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Protein substitution model, from Whelan & Goldman 2001, and free
equilibrium frequencies.

@item LG08+F(theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Protein substitution model, from Le & Gascuel 2008, and free
equilibrium frequencies.

@item Empirical(name=@{chars@}, file=@{path@})
Build a protein substitution model from a file in PAML format, and use 'name' as a namespace for parameters.

@item Empirical+F(name=@{chars@}, file=@{path@}, theta=@{real]0,1[@}, theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., useObservedFreqs=@{boolean@}, useObservedFreqs.pseudoCount=@{int>0@})
Build a protein substitution model from a file in PAML format, and use free equilibrium frequencies. 'name' will be used as a parameter namespace, including for frequencies.

@end table

@subsubsection Codon models

Standard codon models: the optional @var{genetic_code} argument describes the genetic code. If
it is not given, the one related with the alphabet is used. The several values available are described below.

@itemize
@item EchinodermMitochondrialGeneticCode
@item InvertebrateMitochondrialGeneticCode
@item StandardGeneticCode
@item VertebrateMitochondrialGeneticCode
@item YeastMitochondrialGeneticCode
@end itemize

The next codon models also take as argument a @var{frequencies} option 
specifying the equilirium frequencies of the model. Any frequencies description can be used here, but the syntax also supports
options similar to the ones used in the PAML software:
@itemize
@item F0: all frequencies are assumed to be fixed and equal to 1/61, 0 for stop codons.
@item F1X4: 4 distinct frequencies are used, with parameters theta, theta1, theta2 (@xref{Frequencies sets}, ``Full'' method).
@item F3X4: 4 distinct frequencies are used for each position, resulting in 9 parameters in total (3 independent ``Full'' frequencies set).
@item F61: free equilibrium frequencies, stop codons set to 0.
@end itemize

The same words can be used to specify root frequencies for codon
models, in the case of non reversibility.

@table @command

@item GY94([genetic_code=@{genetic code description@} , kappa=@{real>0@}, V=@{real>0@}])
Goldman and Yang (1994) substitution model for codons (default values:
@var{kappa}=1 and @var{V}=10000).

@item MG94([genetic_code=@{genetic code description@}, rho=@{real>0@}])
Muse and Gaut (1994) substitution model for codons (default values:
@var{rho}=1).

@item YN98([genetic_code=@{genetic code description@}, kappa=@{real>0@}, omega=@{real>0@}])
Yang and Nielsen (1998) substitution model for codons (default values:
@var{kappa}=1 and @var{omega}=1).

@item YNGKP_M0([genetic_code=@{genetic code description@}, kappa=@{real>0@}, omega=@{real>0@}])
The M0 model of PAML, ie the same as YN98.

@item YNGKP_M1([genetic_code=@{genetic code description@},kappa=@{real>0@}, omega=@{real>0@}, p0=@{real>0 and <1 @}])
The M1a model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000) (default values: @var{kappa}=1, @var{p0}=0.5,
@var{omega}=0.5).

@item YNGKP_M2([genetic_code=@{genetic code description@},kappa=@{real>0@}, omega0=@{real>0 and <1@}, theta1=@{real>0 and <1 @}],  omega1=@{real>1@},  theta2=@{real>0 and <1 @}])

The M2a model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with  p0=theta1  and
p1=(1-theta1)*theta2 (default values: @var{kappa}=1, @var{theta1}=0.33333,
@var{theta2}=0.5, @var{omega0}=0.5, @var{omega2}=0.5).

@item YNGKP_M3(genetic_code=@{genetic code description@}, n=@{integer>0@}, kappa=@{real>0@}, omega0=@{real>0 and <1@}, delta1=@{real>0@}, ..., delta@var{n-1}=@{real>0@}, theta1=@{real>0 and <1 @}, ..., theta@var{n-1}1=@{real>0 and <1 @}])

The M3 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with @var{n} discrete values, with p0=theta1
and pk=(1-theta1)*...*(1-thetak)*theta(k+1), and
omegak=omega0+delta1+....+deltak (default values: @var{n}=3,
@var{kappa}=1, @var{thetak}=1/(n-k+1), @var{omega0}=0.5, @var{deltak}=0.5).

@item YNGKP_M7(n=@{integer>0@}, [genetic_code=@{genetic code description@},kappa=@{real>0@}, p=@{real>1@}, q=@{real>1 @}])

The M7 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with the Beta distribution discretized in @var{n}
classes (default values: @var{kappa}=1, @var{p}=2, @var{q}=2).

@item YNGKP_M7(n=@{integer>0@}, [genetic_code=@{genetic code description@},kappa=@{real>0@}, omegas=@{real>1@}, p0=@{real>0@},p=@{real>1@}, q=@{real>1 @}])

The M8 model of PAML, see Yang, Z., R. Nielsen, N. Goldman, and A.-M.
K. Pedersen (2000), with the Beta distribution discretized in @var{n}
classes (default values: @var{kappa}=1, @var{p}=2, @var{q}=2,
@var{p0}=0.5, @var{omegas}=2).

@end table

It is also possible to setup more specific models, by specifying a nucleotide model for each position.
Model parameters names then take the form of CodonModel.<position set>_<position model name>.<position specific parameter name>.

@table @command

@item CodonNeutral(model=@{model name@} [, relrate1=@{real>0@}, relrate2=@{real>0@}]) 
or 
@item CodonNeutral(model1=@{model name@}, model2=@{model name@}, model3=@{model name@}[, relrate1=@{real>0@}, relrate2=@{real>0@}]) 

Substitution model on codons. The arguments @var{model} and
@var{model@{i@}} are for descriptions of models on bases. The alphabet
must be a codon alphabet.

If the argument is @var{model}, the @emph{same} single site model is
used on all positions (ie the parameters are shared between all
positions).

If the arguments are @var{model1}, @var{model2}, @var{model3}, each
single site model stands for a single-site substitution model. In that
case, all single site models parameters are position dependent.

Each single site model is normalized and the substitution rates
between codons that differ on more than one letter are null.

Arguments @var{relrate@{i@}} stands for the relative substitution rates
of the sites. Default: @var{relrate@{i@}=1/@{4-i@}}, such that the rate
of each site is 1/3.

The generator is first computed with these models and parameters on
the whole triplet alphabet, and then the substitution rates to and
from stop codons are set to zero and the generator is normalized with
this modification.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonNeutral(model=T92)
@end example
builds a model on codons, such all sites follow the same T92 model.
The parameters names are @var{CodonNeutral.123_T92.kappa},
@var{CodonNeutral.relrate1}, @var{CodonNeutral.relrate2}.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonNeutral(model1=T92, model2=T92, model3=JC69)
@end example
builds a model on codons, such that first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are @var{CodonNeutral.1_T92.kappa},
@var{CodonNeutral.2_T92.kappa}, @var{CodonNeutral.relrate1},
@var{CodonNeutral.relrate2}, and can be initialized as is:

@example
model=CodonNeutral(model1=T92, model2=T92, model3=JC69,\
    1_T92.theta=0.5, 1_T92.kappa=2.0, 2_T92.theta=0.4, 2_T92.kappa=2.0)
@end example

@item CodonAsynonymous(model=@{model name@}[, genetic_code=@{genetic code description@}, beta=@{real>0@}])

or

@item CodonAsynonymous(model1=@{model name@}, model2=@{model name@}, model3=@{model name@}[, geneticcode=@{genetic code description@}, beta=@{real>0@}]) 

substitution model on codons. 

The arguments @var{model} and @var{model@{i@}} are for descriptions of
models on bases. The alphabet must be a codon alphabet.

If the argument is @var{model}, the @emph{same} single site model is
used on all positions (ie the parameters are shared between all
positions).

If the arguments are @var{model1}, @var{model2}, @var{model3}, each
single site model stands for a single-site substitution model. In that
case, all single site models parameters are position dependent.

Each single site model is normalized and the substitution rates
between codons that differ on more than one letter are null.

In addition to these models, the optional @var{geneticcode} argument
describes the genetic code. If it is not given, the one related with
the alphabet is used. The several values available are described
below.

Optional argument @var{beta} is the ratio between non-synonymous
substitution rate and synonymous substitution rate. Default value: 1.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonAsynonymous(model=T92)
@end example
builds a model on codons, such all sites follow the same T92 model.
The parameters names are @var{CodonAsynonymous.123_T92.kappa} and 
@var{CodonAsynonymous.beta}.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonNeutral(model1=T92, model2=T92, model3=JC69)
@end example
builds a model on codons, such that first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are @var{CodonAsynonymous.1_T92.kappa},
@var{CodonAsynonymous.2_T92.kappa}, @var{CodonAsynonymous.beta}.

@item CodonNeutralFrequencies(frequencies=@{frequencies set description@} [, relrate1=@{real>0@}, relrate2=@{real>0@}]) 

substitution model on codons. The exchangeability model on each site
is the same K80 model, and the equilibrium distribution of the model
is description by the @var{frequencies} argument. See the description
of the Frequencies Set below.

Each single site model is normalized and the substitution rates
between codons that differ on more than one letter are null.

Arguments @var{relrate@{i@}} stands for the relative substitution rates
of the sites. Default: @var{relrate@{i@}=1/@{4-i@}}, such that the rate
of each site is 1/3.

The generator is first computed with these model and distribution on
the whole triplet alphabet, and then the substitution rates to and
from stop codons are set to zero and the generator is normalized with
this modification.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonNeutralFrequencies(frequencies=Full())
@end example
has parameters @var{CodonNeutralFrequencies.123_K80.kappa},
@var{CodonNeutralFrequencies.Full.theta_1}, ...,
@var{CodonNeutralFrequencies.Full.theta_60},
@var{CodonNeutralFrequencies.relrate1},
@var{CodonNeutralFrequencies.relrate2}.

@item CodonAsynonymousFrequencies(frequencies=@{frequencies set description@} [geneticcode=@{genetic code description@}, beta=@{real>0@}])

substitution model on codons. The exchangeability model on each site
is the same K80 model, and the equilibrium distribution of the model
is description by the @var{frequencies} argument. See the description
of the Frequencies Set below.

Each single site model is normalized and the substitution rates
between codons that differ on more than one letter are null.

In addition to these models, the optional @var{geneticcode} argument
describes the genetic code. If it is not given, the one related with
the alphabet is used. The several values available are described
below.

Optional argument @var{beta} is the ratio between non-synonymous
substitution rate and synonymous substitution rate. Default value: 1.

The generator is first computed with these model and distribution on
the whole triplet alphabet, and then the substitution rates to and
from stop codons are set to zero and the generator is normalized with
this modification.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=CodonAsynonymousFrequencies(frequencies=Full())
@end example
has parameters @var{CodonAsynonymousFrequencies.012_T92.kappa},
@var{CodonAsynonymousFrequencies.Full.theta_1}, ...,
@var{CodonAsynonymousFrequencies.Full.theta_60},
@var{CodonAsynonymousFrequencies.beta}.


@end table



@subsubsection General multiple site models

@table @command

@item Word(model=@{model name@} [,relrate1=@{1>real>0@}, ..., relrate@{n-1@}=@{1>real>0@}]) 
or 
@item Word(model1=@{model name@}, model1=@{model name@}, ..., modeln=@{model name@}[, relrate1=@{1> real>0@}, ..., relrate@{n-1@}=@{1> real>0@}])

substitution model on words. The arguments @var{model} and
@var{model@{i@}} are for descriptions of models on single sites such
as nucleotides or proteins. The alphabet must be a Word alphabet.

If the argument is @var{model}, the length of the words in the
substitution model is determined by the length of the words in the
alphabet, and the @emph{same} single site model is used (ie the
parameters are shared between all positions).

If the arguments are @var{model1}, ..., @var{model@{n@}}, the length
of the words in the alphabet must be @var{n}, and each single site
model stands for a single-site substitution model. In that case, all
single site models parameters are position dependent.

Each single site model is normalized and the substitution rates
between words that differ on more than one letter are null.

Arguments @var{relrate@{i@}} stands for the relative substitution rates
of the sites. Default: @var{relrate@{i@}=1/@{n-i+1@}}, such that the rate
of each site is 1/n.

@example
alphabet=Word(letter=DNA,length=4)
model=Word(model=T92())
@end example
builds a model on 4 bases words, such all sites follow the same T92
model. The parameters names are @var{Word.1234_T92.kappa},
@var{Word.relrate1}, @var{Word.relrate2}, @var{Word.relrate3}.

@example
alphabet=Word(letter=DNA,length=4)
model=Word(model1=T92(), model2=T92(), model3=JC69(), model4=HKY85())
@end example
builds a model on 4 bases words, such first and second sites follow
independent T92 models, third site follows a JC69 model, and fourth
site follows a HKY85 model. Then the parameters names are
@var{Word.1_T92.kappa}, @var{Word.2_T92.kappa},
@var{Word.4_HKY85.kappa}, @var{Word.4_HKY85.theta},
@var{Word.4_HKY85.theta1}, @var{Word.4_HKY85.theta2},
@var{Word.relrate1}, @var{Word.relrate2}, @var{Word.relrate3}.

@item Triplet(model=@{model description@} [, relrate1=@{real>0@}, relrate2=@{real>0@}]) 
or 
@item Triplet(model1=@{model description@}, model2=@{model description@}, model3=@{model description@}[, relrate1=@{real>0@}, relrate2=@{real>0@}]) 

substitution model on 3 letters words. The arguments @var{model} and
@var{model@{i@}} are for descriptions of models on single sites such as
nucleotides or proteins. The alphabet must be a 3-letters word
alphabet or a codon alphabet.

If the argument is @var{model}, the @emph{same} single site model is
used on all positions (ie the parameters are shared between all
positions).

If the arguments are @var{model1}, @var{model2}, @var{model3}, each
single site model stands for a single-site substitution model. In that
case, all single site models parameters are position dependent.

Each single site model is normalized and the substitution rates
between triplets that differ on more than one letter are null.

Arguments @var{relrate@{i@}} stands for the relative substitution rates
of the sites. Default: @var{relrate@{i@}=1/@{4-i@}}, such that the rate
of each site is 1/3.

@example
alphabet=Codon(letter=DNA, type=Standard)
model=Word(model=T92)
@end example
builds a model on codons, such all sites follow the same T92 model.
The parameters names are @var{Triplet.123_T92.kappa},
@var{Triplet.relrate1}, @var{Triplet.relrate2}.

@example
alphabet=Word(letter=DNA, length=3)
model=Triplet(model1=T92, model2=T92, model3=JC69)
@end example
builds a model on 3 bases words, such first and second sites follow
independent T92 models, and third site follows a JC69 model. Then the
parameters names are @var{Triplet.1_T92.kappa},
@var{Triplet.2_T92.kappa}, @var{Triplet.relrate1},
@var{Triplet.relrate2}.

@end table



@subsubsection Meta models

These substitution models take as argument another substitution model, and add several parameters.
 
@table @command

@item TS98(model=@{model description@}, s1=@{real>0@}, s2=@{real>0@})
Tuffley and Steel 1998's 'covarion' model, taking a nested substitution model as argument for @var{model}.
The nested model can be any substitution model for any alphabet.

@item G01(model=@{model description@}, rdist=@{rate distribution description@}, mu=@{real>0@})
Galtier 2001's 'covarion' model, taking a nested substitution model as argument for @var{model} and a rate distribution for parameter @var{rdist} (see below).
The nested model can be any substitution model for any alphabet.

@item RE08(model=@{model description@}, lambda=@{real>0@}, mu=@{real>0@})
Rivas and Eddy 2008's substitution model with gaps, taking a nested substitution model as argument for @var{model}.
Parameter @var{lambda} is the insertion rate, while @var{mu} is the deletion rate.

@end table

@subsubsection Mixture of models (beta feature)

@table @command

Mixed models combine any sustitution models with a priori distribution
of parameters. Such models are still experimental and have not been
yet fully tested. They should hence be used wih extra care!

During the likelihood computation process, all the submodels of the
mixture are successively applied on the branches, and the mean of all
the likelihoods is computed. With nonhomogeneous reconstruction, since
a mixed model is a random variable, affecting a mixed model to a set
of branches means that all these branches are dependent, and in this
case all the branches of the set have the same submodel at the same
time.

@item MixedModel(model=@{model description@})
Mixture model from a given @var{model} in which some parameters follow
a probabilistic distribution. Any discrete distribution available can
be used @xref{Discrete distributions}. The description of the
parameters distributions is described below.

@example
model=MixedModel(model=TN93(kappa1=Gamma(n=4,alpha=3,beta=1),\
                            kappa2=Exponential(lambda=2),\
                            theta=0.5,theta1=0.2,theta2=0.1))
@end example
has parameters @var{TN93.kappa1_Gamma.alpha},
@var{TN93.kappa1_Gamma.beta},
@var{TN93.kappa2_Exponential.lamba},
@var{TN93.theta}, @var{MixedModel.TN93.theta1},
@var{TN93.theta2}.

@item Mixture(model1=@{model description@},..., modeln=@{model description@} [, relrate1=@{1>real>0@},..., relrate@{n-1@}=@{1>real>0@}, relproba1=@{1>real>0@}, ..., relproba@{n-1@}=@{1>real>0@}])
Mixture model built from several @var{models}: each model has its own
probability and rate. 

Arguments @var{relproba@{i@}} stands for the relative probability and
@var{relrate@{i@}} stands for the relative rate of each model (in the
order the models are given). Default: @var{relproba@{i@}=1/@{n-i+1@}},
such that the probabilty of each site is 1/n, and
@var{relrate@{i@}=1/@{n-i+1@}} such that the rate of each site is 1.

@example
model=Mixture(model1=GY94(), model2=YN98(), relrate1=0.1)
@end example
has parameters@var{Mixture.relrate1}, @var{Mixture.relproba1},
@var{Mixture.1_GY94.kappa}, @var{Mixture.1_GY94.V},
@var{Mixture.2_YN98.kappa}, @var{Mixture.2_YN98.omega}.
@end table

@subsubsection Linking parameters

It is possible to reduce the parameter space by putting extra constraints on parameters, using for instance
@example
model=TN93(kappa1=1.0, kappa2=kappa1, theta=0.5)
@end example
In that particular case the resulting model is strictly equivalent to the HKY85 model. This syntax however allows to define a larger set of models.







@subsection Setting up non-stationary / non-homogeneous models

You can specify a wide range of non-homogeneous models, by combining different options.

@subsubsection One-per-branch non-homogeneous models

This option share the same parameters as the homogeneous case, since the same kind of model is used for each branch. The additional options are the following:
@table @command

@item nonhomogeneous_one_per_branch.shared_parameters = @{list<chars>@}
List the names of the parameters that are shared by all branches.
In Galtier & Gouy model, that would be @var{T92.kappa}, since only the theta parameter is branch-specific.

The '*' wildcard can be used as a suffix, as in
@command{YN98.freq_Word.1_*} for all the parameters whose names start
with @command{YN98.freq_Word.1_}.


@end table

@subsubsection General non-homogeneous models

Bio++ provides a general syntax to specify almost any non-homogeneous model.

@table @command

@item nonhomogeneous.number_of_models = @{int>0@}
Set the number of distinct models to use.

@end table

You now have to configure each model individually, using the syntax introduced for the homogeneous case, excepted that model will be numbered, for instance:

@example
model1 = T92(theta=0.39, kappa=2.79)
@end example

The additional option is available to attach the model to branches in the tree, specified by the id of the upper node in the tree:

@table @command

@item model1.nodes_id = 1,5,10:15,19
Specify the ids of the nodes to which the node is attached.
Id ranges can be specified using the @option{begin:end} syntax.

@end table

You can also make a given model share parameters with another one by writing for instance:
@example
model2 = T92(theta=0.39, kappa=model1.T92.kappa)
@end example
Please note the syntax, parameters are referred to as [model name].[parameter name] in that case. Only parameter from identical models can be aliased in this manner.
To link parameters from different models, you have to use the more general option (warning, currently beta feature!)

@table @command

@item nonhomogeneous.alias = @{list of aliases@}

where each alias is described as `param1->param2'. The full name of the parameters have to be used, see for example:

@example
model1 = T92(theta=0.4, kappa=4)
model2 = GTR(theta=0.4, a = 1.1, b=0.4, c=0.4, d=0.25, e=0.1)
nonhomogeneous.alias=GTR.theta1->T92.theta1
@end example

This option can be used to link parameters of the root frequencies if the model is non-stationary:
@example
nonhomogeneous.root_freq=Full(init=balanced)
nonhomogeneous.alias=Full.theta1->GTR.theta1_1
@end example

Note that this option is only available with the 'general' nonhomogeneous substitution models and will be ignored if used with "one_per_branch".

@end table

Finally, you may find useful the following options:

@table @command

@item output.tree_ids.file = @{@{path@}|none@}
A tree file in newick format, with node ids instead of bootstrap
values, and leaf names with their id as suffix.
The use of that option will cause the program to exit just after producing the tagged tree.

@item output.parameter_names.file = @{@{path@}|none@}
A text file listing all parameter names. This might come handy in order to specify the parameter that should not be optimized (see optimization.ignore_parameter) or aliased (see above).
The use of that option will cause the program to exit just after producing the list file.

@end table

@subsubsection Root frequencies

In case of nonstationary models, the ancestral frequencies are distinct parameters. If a model is assumed to be stationary,
the ``None'' parameter value can be used, which is strictly equivalent to setting
@command{nonhomogeneous.stationary=yes}.

As since version 0.4.0, BppSuite uses the keyval syntax to set up root frequencies,
@table @command
@item nonhomogeneous.root_freq=@{frequency set description@}
@end table

The Frequencies set used can be any of the ones described below @xref{Frequencies sets}, depending on the alphabet used.


@subsection Frequencies sets
@anchor{Frequencies sets}

The following frequencies distributions are available:

@table @command

@item Fixed()
All frequencies are fixed to their initial value and are not estimated.

@item GC(theta=@{real]0,1[@})
For nucleotides only, set the G content equal to the C content.

@item Full(theta1=@{real]0,1[@}, theta2=@{real]0,1[@}, ..., thetaN=@{real]0,1[@})
Full parametrization. Contains N free parameters, where N is equal to the size of the alphabet - 1. For codon models, N is the size of the alphabet - 1 - the number of stop codons, whose frequencies are set to 0.
For nucleotide sequences, theta is the GC content, theta1 is the proportion of A over A+T, and theta2 is the proportion of G over G+C.

@item Word(frequency=@{frequency set description@})

or 

@item Word(frequency1=@{frequency set description@}, frequency2=@{frequency set description@}, ..., frequencyn=@{frequency set description@})

frequencies on words computed as the product of frequencies on the
letters. The arguments @var{frequency} and @var{frequency@{i@}} are for
descriptions of frequency sets on single sites such as nucleotides or
proteins. The alphabet must be a Word alphabet.

If the argument is @var{frequency}, the number of multiplied single
site frequencies is the length of the words in the alphabet, and the
@emph{same} single site frequency set is used (ie the parameters are
shared between all positions).

If the arguments are @var{frequency1}, ..., @var{frequency@{n@}}, the
length of the words in the alphabet must be @var{n}, and all single
site frequency sets are independent. In that case, all single site
frequency set parameters are position dependent.

@example
alphabet=Word(letter=DNA,length=4)
Word(frequency=GC())
@end example
builds a frequency set on 4 bases words, such that all sites
frequencies follow the same GC frequency set model. The parameter
name is @var{Word.1234_GC.theta}.

@example
alphabet=Word(letter=DNA,length=4)
Word(frequency1=GC(),frequency2=GC(),frequency3=Fixed(),\
                      frequency4=Full())
@end example
builds a frequency set on 4 bases words, such first and second sites
follow independent GC frequency sets, third site follows a Fixed
frequency set, and fourth site follows a Full frequency set. Then the
parameters names are @var{Word.1_GC.theta},
@var{Word.2_GC.theta}, @var{Word.4_Full.theta_1},
@var{Word.4_Full.theta_2}, @var{Word.4_Full.theta_3}.

@end table

All functions accept the following arguments, that take priority over the parameter specification:
@table @command

@item init=@{balanced,observed@}
Set all frequencies to the same value, or to their observed counts.

@item pseudoCount=@{integer@}
If the frequencies are set from observed counts, a pseudoCount is
added to all the counts.

@item values=(@{vector<double>@})
Explicitly set all frequencies manually. The size of the input vector should equal the number of resolved states in the alphabet, be in alphabetical order of states, and sum to one.

@end table



@subsection Rate across site distribution

From version 0.4.0, BppSuite uses the keyval syntax for specifying the distributions of substitution rate across sites.

@table @command

@item rate_distribution = @{rate distribution description@}
Specify the rate across sites distribution.

@end table

The rate distribution is set to have a mean of 1.
The following distributions are currently available:

@table @command

@item Uniform
Uses a constant rate across sites.

@item Gamma(n=@{int>=2@}, alpha=@{float>0@})
A discretized gamma distribution of rates, with @var{n} classes, and a
given shape, with mean 1 (scale=shape).

@item Invariant(dist=@{rate distribution description@}, p=@{real[0,1]@})
A composite distribution allowing a special class of invariant site,
with a probability @var{p}.

@end table


@section Discrete distributions
@anchor{Discrete distributions}

Bio++ contains several probability distributions (currently only
dicrete or discretized ones). These are:

@subsection Standard Distributions

@table @command

@item Constant(value=@{float@})
a Dirac distribution on @var{value}, with parameter @var{value}.

@item Beta(n=@{int>=2@}, alpha=@{float>0@}, beta=@{float>0@}) 
a discretized beta distribution, with @var{n} classes, with standard
parameters @var{alpha} and @var{beta}.

@item Gamma(n=@{int>=2@}, alpha=@{float>0@}, beta=@{float>0@}) 
a discretized gamma distribution, with @var{n} classes, a shape
@var{alpha} and a rate @var{beta}, with parameters @var{alpha} and
@var{beta}.

@item Gaussian(n=@{int>=1@}, mu=@{float@}, sigma=@{float>0@}) 
a discretized gaussian distribution, with @var{n} classes, a mean
@var{mu} and a standard deviation @var{sigma}, with parameters
@var{mu} and @var{sigma}.

@item Exponential(n=@{int>=2@}, lambda=@{float>0@})
a discretized exponential distribution, with @var{n} classes and
parameter @var{lambda}.

@item Simple(values=@{vector<double>@}, probas=@{vector<double>@})
a discrete distribution with specific values (in @var{values}) and
their respective non-negative probabibilities (in @var{probas}). The
parameters are @var{V1}, @var{V2}, ..., @var{Vn} for all the values
and the relative probabibility parameters are @var{theta1},
@var{theta2}, ..., @var{thetan-1}.

@item TruncExponential(n=@{int>=2@}, lambda=@{float>0@}, tp=@{float>0@})
a discretized truncated exponential distribution, with @var{n}
classes, parameter @var{lambda} and a truncation point @var{tp}. The
parameters are @var{lambda} and @var{tp}.

@item Uniform(n=@{int>=1@}, begin=@{float>0@}, end=@{float>0@})
a uniform distribution, with @var{n} classes in interval
[@var{begin},@var{end}]. There are no parameters.

@end table

@subsection Mixture Distributions

@table @command

@item Mixture(probas=@{vector<double>@}, distribution1=@{distribution description@}, ..., distributionn=@{distribution description@}) 

a Mixture of discrete distributions with specific probabilities (in
@var{probas}) and their respective desccriptions. (in @var{probas}).
The parameters are the relative probabibility parameters @var{theta1},
@var{theta2}, ..., @var{thetan-1}, and the parameters of the included
distributions prefixed by @var{Mixture.i_} where @var{i} is the order
of the distribution.

For example:
@example
Mixture(probas=(0.3,0.7),distribution1=Beta(n=5,alpha=2,beta=3),\
                       distribution2=Gamma(n=10,alpha=9,beta=2)) 
@end example
builds a mixture of a discrete beta distribution and of a discrete
gamma distribution, with a total of 15 classes. The parameters names
are @var{Mixture.theta1}, @var{Mixture.1_Beta.alpha},
@var{Mixture.1_Beta.beta}, @var{Mixture.2_Gamma.alpha} and
@var{Mixture.2_Gamma.beta}.

@end table


@c ------------------------------------------------------------------------------------------------------------------

@node Estimation, WritingSequences, Model, Common
@section Numerical parameters estimation

Some programs allow you to (re-)estimate numerical parameters, including
@itemize @bullet
@item
Branch lengths

@item
Entries of the substitution matrices, included base frequencies values)

@item
Parameters of the rate distribution (currently shape parameter of the gamma law, proportion of invariant sites).

@end itemize

@table @command

@item optimization = @{method@}
where ``method'' can be one of

@table @command
@item None
  (no optimization is performed, initial values are kept ``as is''.

@item FullD(derivatives=@{Newton|Gradient@})
Full-derivatives method. Branch length derivatives are computed
analytically, others numerically. The @var{derivatives} arguments
specifies if first or second order derivatives should be used. In the
first case, the optimization method used is the so-called conjugate
gradient method, otherwise the Newton-Raphson method will be used.

@item D-Brent(derivatives=@{Newton|Gradient@}, nstep=@{int>0@})
Branch lengths parameters are optimized using either the conjugate
gradient or the Newton-Raphson method, other parameters are estimated
using the Brent method in one dimension. The algorithm then loops over
all parameters until convergence. The @var{nstep} arguments allow to
specify a number of progressive steps to perform during optimization.
If @option{nstep=3} and @option{precision=E-6}, a first optimization
with @option{precision=E-2}, will be performed, then a round with
@option{precision} set to E-4 and finally @option{precision} will be
set to E-6. This approach generally increases convergence time.

@item D-BFGS(derivatives=@{Newton|Gradient@}, nstep=@{int>0@})
Branch lengths parameters are optimized using either the conjugate
gradient or the Newton-Raphson method, other parameters are estimated
using the BFGS method. The algorithm then loops over all parameters
until convergence. The @var{nstep} arguments allow to specify a number
of progressive steps to perform during optimization. If
@option{nstep=3} and @option{precision=E-6}, a first optimization with
@option{precision=E-2}, will be performed, then a round with
@option{precision} set to E-4 and finally @option{precision} will be
set to E-6. This approach generally increases convergence time.
@end table

@item optimization.reparametrization = @{boolean@}
Tells if parameters should be transformed in order to remove constraints
(for instance positivie-only parameters will be log transformed in order to obtain
 parameters defined from -inf to +inf).
This may improve the optimization, particularly for parameter-rich models,
but the likelihood calculations will take a bit more time.

@item optimization.final = @{powell|simplex@}
Optional final optimization step, useful if numerical derivatives are to be used.
Leave the field empty in order to skip this step.

@item optimization.profiler = @{@{path@}|std|none@}
A file where to dump optimization steps (a file path or std for
standard output or none for no output).

@item optimization.message_handler = @{@{path@}|std|none@}
A file where to dump warning messages.

@item optimization.max_number_f_eval = @{int<0@}
The maximum number of likelihood evaluations to perform.

@item optimization.ignore_parameter = @{list<chars>@}
A list of parameters to ignore during the estimation process. The
parameter name should include there "namespace", that is their model
name, for instance K80.kappa, TN93.theta, GTR.a, Gamma.alpha, etc. For
nested models, the syntax is the following:
@command{G01.rdist_Gamma.alpha}, @command{TS98.model_T92.kappa},
@command{RE08.lamba}, @command{RE08.model_G01.model_GTR.a}, etc.
'Ancient' will ignore all parameters in the ancestral frequency set
(non-homogeneous models), and 'BrLen' will ignore all branch lengths.

The '*' wildcard can be used as a suffix, as in
@command{YN98.freq_Word.1_*} for all the parameters whose names start
with @command{YN98.freq_Word.1_}.

@item optimization.tolerance = @{float>0@}
The precision on the log-likelihood to reach.

@item output.tree.file = @{@{path@}|none@}
File path where to write the optimized tree.

@item output.infos = @{@{path@}|none@}
A text file containing several statistics for each site in the
alignment.
These statistics include the posterior rate, rate class with maximum posterior probability and whether the site is conserved or not.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node WritingSequences,  , Estimation, Common
@section Writing sequences/alignments to files

@table @command

@item output.sequence.file = @{path@}
The output file where to write the sequences.

@item output.sequence.format = @{sequence format description@}
The output file format, using the same syntax as for reading (@pxref{Sequences}).
Only formats Fasta, Mase and Phylip are supported for writing.
In addition, most of the formats support the @command{length} argument, that specifies the maximum number of sequence characters to output on each line (default set to 100).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Reference,  , Common, Top
@chapter Bio++ Program Suite Reference

@c ------------------------------------------------------------------------------------------------------------------

This section now details the specific options for each program in the Bio++ Program suite.

@c ------------------------------------------------------------------------------------------------------------------

@menu
* bppml::                       Bio++ Maximum Likelihood.
* bppseqgen::                   Bio++ Sequence Generator.
* bppancestor::                 Bio++ Ancestral Sequences and Rates reconstruction.
* bppdist::                     Bio++ Distance Methods.
* bpppars::                     Bio++ Maximum Parsimony.
* bppconsense::                 Bio++ Consensus Trees.
* bppphysamp::                  Bio++ Phylogenetic Sampler.
* bppreroot::                   Bio++ Serial Tree Re-rooting.
* bppseqman::                   Bio++ Sequences Manipulation.
* bpptreedraw::                 Bio++ Tree Drawing.
@end menu

@node bppml, bppseqgen, Reference, Reference
@section BppML: Bio++ Maximum Likelihood

The BppML program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (@pxref{Sequences}), specifying the model (@pxref{Model}), and estimating parameters (@pxref{Estimation}).

The BppML program allows you to optimize tree topologies and model parameters and perform a bootstrap analysis.

@subsection Branch lengths initial values

@table @command

@item init.tree = @{user|random@}
Set the method for the initial tree to use.
The @option{user} option allows you to use an existing file using the method described in the Common options section.
This file may have been built using another method like neighbor joining or parsimony for instance.
The @option{random} option picks a random tree, which is handy to test convergence.
This may however slows down significantly the optimization process.

@item init.brlen.method = @{method description@}
Set how to initialize the branch lengths.
Available methods include:

@table @command

@item Input
Keep initial branch lengths as is.

@item Equal(value=@{float>0@})
Set all branch lengths to the same value, provided as argumet.

@item Clock
Coerce to a clock tree.

@item Grafen(height=@{@{real>0@}|input@}, rho = @{real>0@})
Uses Grafen's method to compute branch lengths.
In Grafen's method, each node is given a weight equal to the number of underlying leaves.
The length of each branch is then computed as the difference of the weights of the connected nodes, and further divided by the number of leaves in the tree.
The height of all nodes are then raised to the power of 'rho', a user specified value.
The tree is finally scaled to match a given total height, which can be the original one (@option{height=input}), or fixed to a certain value (usually @option{height=1}).
A value of rho=0 provides a star tree, and the greater the value of rho, the more recent the inner nodes. 

@end table
@end table

@subsection Topology optimization

@table @command

@item optimization.topology = @{boolean@}
Enable the tree topology estimation.

@item optimization.topology.algorithm = @{NNI@}
Algorithm to use for topology estimation: only NNI available for now.

@item optimization.topology.algorithm_nni.method = @{fast|better|phyml@}
Set the NNI method to use.
@option{fast}: test sequentially all NNI, if a NNI improving the likelihood is found, it is performed.
@option{better}: test all possible NNIs, do the one with the biggest likelihood increase.
@option{phyml}: test all possible NNIs, try doing all the improving ones.
If the final likelihoods is better, perform all NNIs.
Otherwise, try to do half of them, and so on. 
In most cases the @option{phyml} option shows the best performance.

@item optimization.topology.nstep = @{int>0@}
Number of phyml topology movement steps before re-optimizing parameters.

@item optimization.topology.numfirst = @{boolean@}
Shall we estimate parameters before looking for topology movements?

@item optimization.topology.tolerance.before = @{real>0@}
Tolerance for the prior-topology estimation.
The tolerance numbers should not be too low, in order to save computation time and also for a better topology estimation.
The @option{optimization.tolerance} parameter will be used for the final optimization of numerical parameters (see Common options).

@item optimization.topology.tolerance.during = 100
Tolerance for the during-topology estimation

@item optimization.scale_first = no
Shall we first scale the tree before optimizing parameters?

@item optimization.scale_first.tolerance = @{double@}
The convergence criterion to achieve in the optimization.

@end table


@subsection Molecular clock

BppML can also optimize branch lengths with a molecular clock:

@table @command

@item optimize.clock=@{no|global@}
Tell if a molecular clock should be assumed.
Topology estimation is not possible with a clock constraint.

@end table


@subsection Output results

@table @command

@item output.infos = @{@{path@}|none@}
Alignment information log file (site specific rates, etc):

@item output.estimates = @{@{path@}|none@}
Write numerical parameter estimated values.

@end table

@subsection Bootstrap analysis

@table @command

@item bootstrap.number = @{int>0@}
Number of replicates. A reasonable value would be >= 100.

@item bootstrap.approximate = @{boolean@}
Tell if numerical parameters should be kept to their initial value when bootstrapping. 

@item bootstrap.verbose = @{boolean@}
Set this to yes for detailed output when bootstrapping. 

@item bootstrap.output.file = @{@{path@}|none@}
Where to write the resulting trees (multi-trees newick format).

@end table

@subsection Rather technical options

Theses options are mainly for debugging or testing purpose, in most case you will be happy with the default setting.

@table @command

@item likelihood.recursion = @{simple|double@}
Set the type of likelihood recursion to use.
@option{simple}: derivatives take more time to compute, but likelihood computation is faster.
For big data sets, it can save a lot of memory usage too, particularly when the data are compressed.
@option{double}: uses more memory and need more time to compute likelihood, due to the double recursion.
Analytical derivatives are however faster to compute.

This command has no effect in the following cases: (i) topology estimation: this requires a double recursive algorithm, (ii) optimization with a molecular clock: a simple recursion with data compression is used in this case, due to the impossibility of computing analytical derivatives.

@item likelihood.recursion_simple.compression = @{simple|recursive@}

Site compression for the simple recursion:
@option{simple}: identical sites are not computed twice, @option{recursive}: look for site patterns to save computation time during optimization, but requires extra time for building the patterns.
This is usually the best option, particularly for nucleotide data sets.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bppseqgen, bppancestor, bppml, Reference
@section BppSeqGen: Bio++ Sequence Simulator

The BppSeqGen program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (@pxref{Sequences}) and tree (@pxref{Tree}), specifying the model (@pxref{Model}) and writing sequence data (@pxref{WritingSequences}).

@table @command

@item number_of_sites = @{int>0@}
The number of site positions to simulate.

@item input.infos = @{path@}
A info file like the one output by bppML.
The estimated site-specific rates will then be used to simulate the same number of sites as found in the info file, with the corresponding rates.

@end table
 
@c ------------------------------------------------------------------------------------------------------------------

@node bppancestor, bppdist, bppseqgen, Reference
@section BppAncestor: Bio++ Ancestral Sequence and Rate Reconstruction

The BppAncestor program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (@pxref{Sequences}) and tree (@pxref{Tree}), specifying the model (@pxref{Model}) and writing sequence data (@pxref{WritingSequences}).

Specific options are:
@table @command

@item asr.method = @{none|marginal@}
Marginal is the only option for now. If set to "none", only nodes frequencies can be output.

@item asr.probabilities = @{boolean@}
Tells if we should output the site specific probabilities in each case.

@item asr.sample = @{boolean@}
Tell if we should sample from the posterior distribution instead of using the maximum probability.

@item asr.sample.number = 10 [[asr.sample=yes]]
Number of sample sequences to output.

@item asr.add_extant = @{boolean@}
Should extant (observed) sequences be added to the output sequence file?
The sequences added are the ones which are used for the actual calculation.
It they contained gaps for instance, and that these have been replaced by the unknown character (N or X for example),
then the sequence with unknown characters will be used.

@item output.sites.file = @{@{path@}|none@}
Alignment information log file (site specific rates, probabilities, etc).

@item output.nodes.file = @{@{path@}|none@}
Ancestral nodes information: expected frequencies of ancestral states.

@item output.nodes.add_extant = @{boolean@}
Tell if leaf nodes should be added to the output file.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bppdist, bpppars, bppancestor, Reference
@section BppDist: Bio++ Distance Methods
 
The BppDist program uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (@pxref{Sequences}) and tree (@pxref{Tree}) and specifying the model (@pxref{Model}, only the section corresponding to the homogeneous case).

Specific options are:
@table @command

@item output.matrix.file = @{@{path@}|none@}
Where to write the matrix file (only philip format supported for now).

@item method = @{wpgma|upgma|nj|bionj@}
The algorithm to use to build the tree.

@item optimization.method = @{init|pairwise|iterations@}
There are several ways to optimize substitution parameters.
The @option{init} option corresponds to the standard behavior, that is, keeping them to their initial, user-provided value.
The @option{pairwise} option estimate those parameters in a pairwise manner.
This should be avoided, particularly with parameter-rich models.
Finally the @option{iterations} option corresponds to Ninio et al, Bioinformatics (2007) recursive algorithm:
After each distance tree, a global ML estimation of the substitution parameters is performed.
The estimated values are then used to rebuild a distance matrix and a tree.
The algorithm stops when the topology does not change anymore.
The ML optimization uses the parameters described in (@pxref{Estimation}).

@item output.tree.file = @{@{path@}|none@}
The final tree, possibly with bootstrap values:
BppDist uses the same options for bootstrap analysis than the BppML program (@pxref{bppml}).
@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bpppars, bppconsense, bppdist, Reference
@section BppPars: Bio++ Maximum Parsimony
 
The BppPars program is currently quite limited and should not be used for serious phylogenetic analysis.
It can compute parsimony scores and perform topology estimation using the same algorithm of BppML.
It uses the common syntax introduced in the previous section for setting the alphabet, loading the sequences (@pxref{Sequences}) and tree (@pxref{Tree})).

Specific options are:
@table @command

@item optimization.topology = @{boolean@}
Tell if topology has to be estimated.

@item output.tree.file = @{@{path@}|none@}
Where to print the output file.

@item bootstrap.number = @{int>0@}
Number of bootstrap replicates to perform.

@item bootstrap.output.file = @{@{path@}|none@}
Where to write bootstrap trees.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bppconsense, bppphysamp, bpppars, Reference
@section BppConsense: Bio++ Consensus Trees

Probably one of the simplest program to use in the suite, just takes a list of trees (for instance produced by BppML, BppDist or BppPars with the bootstrap option enabled) and compute bootstrap values for a reference tree, provided as input, or constructed using a consensus method.
The program uses the multiple-trees reading options for input (@pxref{Tree}) and single-tree writing options for output.

There are only specific options here:
@table @command

@item tree = @{tree methods@}
The method to use for getting the reference tree.
Available function are:

@table @command

@item Input
The tree is loaded using the single-tree reading options (@pxref{Tree}). 

@item Consensus(threshold = @{int[0,1]@})
Build a consensus tree according to a given threshold.
0 will output a fully resolved tree, 0.5 corresponds to the majority rule and 1 to the strict consensus, but any intermediate value can be specified.

@end table

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bppphysamp, bppreroot, bppconsense, Reference
@section BppPhySamp: Bio++ Phylogenetic Sampler
 
The Bio++ Phylogenetic Sampler samples sequences from a file according to phylogenetic information.
The goal is to clean a big data set by removing redundant sequences, bringing only few additional information for evolutionary analyses.

The BppPhySamp programs uses the common options for setting the alphabet, loading the sequences (@pxref{Sequences}) and (@pxref{Tree}) and writing the resulting data set (@pxref{WritingSequences}).

@table @command

@item input.method = @{tree|matrix@}
The method to provide phylogenetic information, either by a tree or a matrix.
If the @option{tree} option is used, then the options for reading trees are used (@pxref{Tree}).

@item input.matrix = @{path@} [[input.method = matrix]]
The input matrix file.

@item deletion_method = @{random|threshold|sample@}
Method to use to remove sequence. 

@item threshold = @{float>0@} [[deletion_method = threshold ]]
The minimum distance separating two sequences in the sampled data set.
Any sequences closer than this threshold in the original data set will be confronted so that only one is kept.

@item sample_size = @{int>0@} [[deletion_method = sample|random ]]
The number of sequences to keep in the final data set.

@item choice_criterion = @{length|length.complete|random@}
How to chose between closely related sequences? @option{length} takes the longest (maximum number of non-gap positions), @option{length.complete} takes the sequence with the maximum number of fully resolved positions and @option{random} picks one sequence at random.
@end table 

@c ------------------------------------------------------------------------------------------------------------------

@node bppreroot, bppseqman, bppphysamp, Reference
@section BppReroot: Bio++ Serial Tree Re-rooting
 
@table @command

@item input.trees.file=@{path@}
A path toward multi-trees file (newick).

@item outgroups.file=@{path@}
A path toward a file containing the different levels of outgroups.

@item print.option=@{boolean@}
If set to true, the unrootable trees are printed as unrooted in the output file, otherwise the unrootable trees are not printed.
  
@item tryAgain.option=@{boolean@}
If set to true and ReRoot finds a non-monophyletic outgroup, it tries the next outgroup.
Otherwise, if ReRoot finds a non-monophyletic outgroup, the analysis for this tree is interrupted.
No more outgroup are analysed.

@item output.trees.file=@{path@}
File where to write the rerooted trees.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bppseqman, bpptreedraw, bppreroot, Reference
@section BppSeqMan: Bio++ Sequence Manipulation

The Bio++ Sequence Manipulator convert between various file formats, and can also perform various operations on sequences.
It uses the common options for setting the alphabet, loading the sequences (@pxref{Sequences}) and writing the resulting data set (@pxref{WritingSequences}).
It can use the ``Generic'' option for alphabets if only file format conversion is to be performed, but the correct alphabet must be specified for more advanced manipulations, like in silico molecular biology.

BppSeqMan can perform any number of elementary operation, in any order, providing the output of operation n is compatible with input of operation n+1, and that the input of operation 1 is compatible with the input data.

Specific options:
@table @command

@item sequence.manip = @{list<string>@}
The list, in appropriate order, of elementary operations to perform.
See below for a list of these operations.
@end table

@table @option
@item Complement [[alphabet = DNA or RNA]]
Convert to the complementary sequence, keeping the original alphabet.

@item Transcript [[alphabet = DNA or RNA]]
Convert to the complementary sequence, switching the type of alphabet (DNA<->RNA).

@item Switch [[alphabet = DNA or RNA]]
Change the alphabet type (DNA<->RNA).

@item Translate(code = @{genetic code@}) [[alphabet = DNA or RNA]]
Convert to proteins. You have to specify a genetic code, see specific options.
@option{code}: The genetic code to use for the translation, one of
@itemize
@item EchinodermMitochondrialGeneticCode
@item InvertebrateMitochondrialGeneticCode
@item StandardGeneticCode
@item VertebrateMitochondrialGeneticCode
@item YeastMitochondrialGeneticCode
@end itemize

@item Invert
Invert the sequence 5' <-> 3' or N <-> C

@item RemoveGaps
Remove all gaps in sequences (ie, 'unalign').

@item GapToUnknown
Change gaps to fully unresolved characters, N for nucleotides and X for proteins.

@item UnknownToGap
Change (partially) unresolved characters to gaps.

@item RemoveStops
Remove all sites with at least one stop codon.

@item GetCDS
Remove the first stop codon and everything after in codon sequences.

@item CoerceToAlignment
Try to convert a set of sequence to an alignment. This will fail if sequences do not have the same length.
This step is required before trying commands 'ResolveDotted' or 'KeepComplete'.

@item ResolveDotted(alphabet=@{RNA|DNA|Proteins@}) [[Aligned sequences]]
Convert a human-readable alignment to a machine-readable alignment.
This manipulation must be first if it is used, and the data must be load with the @option{Generic} alphabet.
@option{alphabet}: The alphabet to use in order to resolve a dotted alignment.

@item KeepComplete(maxGapAllowed=@{int>0@} or @{float[0,100]@}+%) [[Aligned sequences]]
Keep only complete sites, ie sites without any gap. Sites with unresolved characters are not removed.
It is also possible to fix a maximum proportion of gaps, see specific options.
@option{maxGapAllowed}: The maximum proportion of gaps allowed.

@end table

Examples of use:

@table @bullet

@item Just change file format:
@example
sequence.manip=
@end example

@item Change DNA to RNA:
@example
sequence.manip=Switch
@end example

@item Unalign sequences, perform transcription and translate to proteins:
@example
sequence.manip=RemoveGaps,Transcript,Translate
@end example

@item Change all unresolved characters to gaps and keep only positions with less than 5 gaps:
@example
sequence.manip=UnknownToGap,KeepComplete(maxGapAllowed=5)
@end example

@item Keep only positions with less than 30% of gaps, and change them to unresolved characters:
@example
sequence.manip=KeepComplete(maxGapAllowed=30%),GapToUnknown
@end example

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node bpptreedraw, , bppseqman, Reference
@section BppTreeDraw: Bio++ Tree Drawing

This is a simple program that outputs a tree in various vector formats.
It takes as input a tree following the standard syntax.

Specific options:
@table @command

@item output.drawing.file = @{path@}
The file where to output the figure.

@item output.drawing.format = @{Svg|Xfig|Inkscape|Pgf@}
The file format.
@item output.drawing.plot = @{plotting algorithm@}
The plotting algorithm can be either Phylogram or Cladogram.
They follow the keyval syntax, with the following arguments:
@end table

@table @option
@item xu, yu @{float@}
The scale units for x and y axis.

@item direction.h @{left2right|right2left@}
Horizontal orientation of the tree plot.

@item direction.v @{top2bottom|bottom2top@}
Vertical orientation of the tree plot.

@item draw.leaves, draw.ids, draw.brlen, draw.bs @{boolean@}
Tell if leaf names, node ids, branch lengths and/or bootstrap should be drawn.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@c ------------------------------------------------------------------------------------------------------------------
@c end of document

@c @node Index,  , Reference, Top
@c @unnumbered Index
@c
@c @printindex cp

@bye
